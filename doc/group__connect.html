<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::connect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::connect</div>  </div>
</div><!--header-->
<div class="contents">

<p>Establishes a socket connection by trying each endpoint in a sequence.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">More...</a><br /></td></tr>
<tr class="separator:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gabb07ab5112f0691f7ec319a84d8706ff">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gabb07ab5112f0691f7ec319a84d8706ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gabb07ab5112f0691f7ec319a84d8706ff">More...</a><br /></td></tr>
<tr class="separator:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gaac570187376d86ed0ae4e159ddd3d6b9">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gaac570187376d86ed0ae4e159ddd3d6b9">More...</a><br /></td></tr>
<tr class="separator:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga8fd534f58d767632b799b3ba29cb1e5d">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga8fd534f58d767632b799b3ba29cb1e5d">More...</a><br /></td></tr>
<tr class="separator:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gad92e38c4005f169f69e30fdbbae6bb46">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:gad92e38c4005f169f69e30fdbbae6bb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gad92e38c4005f169f69e30fdbbae6bb46">More...</a><br /></td></tr>
<tr class="separator:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5e651070d3127a66d87faac7521ee3"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:ga7a5e651070d3127a66d87faac7521ee3"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga7a5e651070d3127a66d87faac7521ee3">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga7a5e651070d3127a66d87faac7521ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga7a5e651070d3127a66d87faac7521ee3">More...</a><br /></td></tr>
<tr class="separator:ga7a5e651070d3127a66d87faac7521ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac43057df8f70d23e313310a19116e583"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gac43057df8f70d23e313310a19116e583"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gac43057df8f70d23e313310a19116e583">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gac43057df8f70d23e313310a19116e583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gac43057df8f70d23e313310a19116e583">More...</a><br /></td></tr>
<tr class="separator:gac43057df8f70d23e313310a19116e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga35cdf789e5a013b6b63e15de08b8d4e8">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga35cdf789e5a013b6b63e15de08b8d4e8">More...</a><br /></td></tr>
<tr class="separator:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga531b567bb82e2abd685fcd8b54ed15a5">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga531b567bb82e2abd685fcd8b54ed15a5">More...</a><br /></td></tr>
<tr class="separator:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga7301de14795b08258d5e3f1e0a26e9a8">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga7301de14795b08258d5e3f1e0a26e9a8">More...</a><br /></td></tr>
<tr class="separator:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gaa4f0cd4c95adf783456fb15ef701a17f">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition)</td></tr>
<tr class="memdesc:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gaa4f0cd4c95adf783456fb15ef701a17f">More...</a><br /></td></tr>
<tr class="separator:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7354011ebba2032c1b47123888838e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gacc7354011ebba2032c1b47123888838e"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gacc7354011ebba2032c1b47123888838e">asio::connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gacc7354011ebba2032c1b47123888838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gacc7354011ebba2032c1b47123888838e">More...</a><br /></td></tr>
<tr class="separator:gacc7354011ebba2032c1b47123888838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga725adb77fb09fd5ba569f3fbbd65427b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga725adb77fb09fd5ba569f3fbbd65427b">&#9670;&nbsp;</a></span>connect() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s, r.resolve(q)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gabb07ab5112f0691f7ec319a84d8706ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb07ab5112f0691f7ec319a84d8706ff">&#9670;&nbsp;</a></span>connect() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line"><a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s, r.resolve(q), ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaac570187376d86ed0ae4e159ddd3d6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac570187376d86ed0ae4e159ddd3d6b9">&#9670;&nbsp;</a></span>connect() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="ga8fd534f58d767632b799b3ba29cb1e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd534f58d767632b799b3ba29cb1e5d">&#9670;&nbsp;</a></span>connect() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="gad92e38c4005f169f69e30fdbbae6bb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92e38c4005f169f69e30fdbbae6bb46">&#9670;&nbsp;</a></span>connect() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::resolver::results_type e = r.resolve(q);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s, e.begin(), e.end()); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga7a5e651070d3127a66d87faac7521ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a5e651070d3127a66d87faac7521ee3">&#9670;&nbsp;</a></span>connect() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::resolver::results_type e = r.resolve(q);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line"><a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s, e.begin(), e.end(), ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gac43057df8f70d23e313310a19116e583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac43057df8f70d23e313310a19116e583">&#9670;&nbsp;</a></span>connect() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">tcp::endpoint</a> e = <a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s,</div><div class="line">    r.resolve(q), my_connect_condition());</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl; </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga35cdf789e5a013b6b63e15de08b8d4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35cdf789e5a013b6b63e15de08b8d4e8">&#9670;&nbsp;</a></span>connect() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::endpoint asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the successfully connected endpoint. Otherwise, a default-constructed endpoint.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line"><a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">tcp::endpoint</a> e = <a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(s,</div><div class="line">    r.resolve(q), my_connect_condition(), ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga531b567bb82e2abd685fcd8b54ed15a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga531b567bb82e2abd685fcd8b54ed15a5">&#9670;&nbsp;</a></span>connect() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="ga7301de14795b08258d5e3f1e0a26e9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7301de14795b08258d5e3f1e0a26e9a8">&#9670;&nbsp;</a></span>connect() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="gaa4f0cd4c95adf783456fb15ef701a17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4f0cd4c95adf783456fb15ef701a17f">&#9670;&nbsp;</a></span>connect() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator denoting the successfully connected endpoint.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the sequence is empty, the associated <code><a class="el" href="classasio_1_1error__code.html" title="Class to represent an error code value. ">error_code</a></code> is <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::resolver::results_type e = r.resolve(q);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">tcp::resolver::results_type::iterator</a> i = <a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(</div><div class="line">    s, e.begin(), e.end(), my_connect_condition());</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl; </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gacc7354011ebba2032c1b47123888838e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc7354011ebba2032c1b47123888838e">&#9670;&nbsp;</a></span>connect() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Iterator asio::connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the sequence is empty, set to <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847a6cfdfb1e108e927e2bfc847850ba0dcb" title="Element not found. ">asio::error::not_found</a>. Otherwise, contains the error from the last connection attempt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, an iterator denoting the successfully connected endpoint. Otherwise, the end iterator.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::resolver::results_type e = r.resolve(q);</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line"><a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">tcp::resolver::results_type::iterator</a> i = <a class="code" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">asio::connect</a>(</div><div class="line">    s, e.begin(), e.end(), my_connect_condition());</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
