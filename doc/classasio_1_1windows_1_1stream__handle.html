<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::windows::stream_handle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="namespaceasio_1_1windows.html">windows</a></li><li class="navelem"><a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classasio_1_1windows_1_1stream__handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asio::windows::stream_handle Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides stream-oriented handle functionality.  
 <a href="classasio_1_1windows_1_1stream__handle.html#details">More...</a></p>

<p>Inherits <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html">asio::windows::overlapped_handle</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a15940b7e01577a37dc17aeb9dce6d2f0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context_1_1executor__type.html">io_context::executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a15940b7e01577a37dc17aeb9dce6d2f0">executor_type</a></td></tr>
<tr class="memdesc:a15940b7e01577a37dc17aeb9dce6d2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="#a15940b7e01577a37dc17aeb9dce6d2f0">More...</a><br /></td></tr>
<tr class="separator:a15940b7e01577a37dc17aeb9dce6d2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1ebc42b9077ef7d88c62def4543e09"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a></td></tr>
<tr class="memdesc:a0e1ebc42b9077ef7d88c62def4543e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of a handle.  <a href="#a0e1ebc42b9077ef7d88c62def4543e09">More...</a><br /></td></tr>
<tr class="separator:a0e1ebc42b9077ef7d88c62def4543e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5aaeda5763f215bbca16fea1310579b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html">overlapped_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">lowest_layer_type</a></td></tr>
<tr class="memdesc:ac5aaeda5763f215bbca16fea1310579b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html" title="Provides Windows handle functionality for objects that support overlapped I/O. ">overlapped_handle</a> is always the lowest layer.  <a href="#ac5aaeda5763f215bbca16fea1310579b">More...</a><br /></td></tr>
<tr class="separator:ac5aaeda5763f215bbca16fea1310579b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acaf97eb9811a484a7a5c53ac02740108"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#acaf97eb9811a484a7a5c53ac02740108">stream_handle</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>)</td></tr>
<tr class="memdesc:acaf97eb9811a484a7a5c53ac02740108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> without opening it.  <a href="#acaf97eb9811a484a7a5c53ac02740108">More...</a><br /></td></tr>
<tr class="separator:acaf97eb9811a484a7a5c53ac02740108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8832a1118e1efbea1817d970fffb02f7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a8832a1118e1efbea1817d970fffb02f7">stream_handle</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;handle)</td></tr>
<tr class="memdesc:a8832a1118e1efbea1817d970fffb02f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> on an existing native handle.  <a href="#a8832a1118e1efbea1817d970fffb02f7">More...</a><br /></td></tr>
<tr class="separator:a8832a1118e1efbea1817d970fffb02f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db86488ae17ed99ae51102ffb755eba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a9db86488ae17ed99ae51102ffb755eba">stream_handle</a> (<a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a9db86488ae17ed99ae51102ffb755eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> from another.  <a href="#a9db86488ae17ed99ae51102ffb755eba">More...</a><br /></td></tr>
<tr class="separator:a9db86488ae17ed99ae51102ffb755eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f1636b0f52c1a5ba1c7c8359d0598e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#ac8f1636b0f52c1a5ba1c7c8359d0598e">operator=</a> (<a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ac8f1636b0f52c1a5ba1c7c8359d0598e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> from another.  <a href="#ac8f1636b0f52c1a5ba1c7c8359d0598e">More...</a><br /></td></tr>
<tr class="separator:ac8f1636b0f52c1a5ba1c7c8359d0598e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd56eef44470178c5e9b3229f4c87f8"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a0dd56eef44470178c5e9b3229f4c87f8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a0dd56eef44470178c5e9b3229f4c87f8">write_some</a> (const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a0dd56eef44470178c5e9b3229f4c87f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the handle.  <a href="#a0dd56eef44470178c5e9b3229f4c87f8">More...</a><br /></td></tr>
<tr class="separator:a0dd56eef44470178c5e9b3229f4c87f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c76234373f93409d2ea26fc545a6bc"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a89c76234373f93409d2ea26fc545a6bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a89c76234373f93409d2ea26fc545a6bc">write_some</a> (const ConstBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a89c76234373f93409d2ea26fc545a6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write some data to the handle.  <a href="#a89c76234373f93409d2ea26fc545a6bc">More...</a><br /></td></tr>
<tr class="separator:a89c76234373f93409d2ea26fc545a6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9dcca6383a4ec105611b705e57bb74"><td class="memTemplParams" colspan="2">template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:a1b9dcca6383a4ec105611b705e57bb74"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a1b9dcca6383a4ec105611b705e57bb74">async_write_some</a> (const ConstBufferSequence &amp;buffers, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a1b9dcca6383a4ec105611b705e57bb74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous write.  <a href="#a1b9dcca6383a4ec105611b705e57bb74">More...</a><br /></td></tr>
<tr class="separator:a1b9dcca6383a4ec105611b705e57bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471fc09e50b701f10339c0b81579d699"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a471fc09e50b701f10339c0b81579d699"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a471fc09e50b701f10339c0b81579d699">read_some</a> (const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a471fc09e50b701f10339c0b81579d699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the handle.  <a href="#a471fc09e50b701f10339c0b81579d699">More...</a><br /></td></tr>
<tr class="separator:a471fc09e50b701f10339c0b81579d699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d3e13d17c27a9cedb6001836534b81"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a33d3e13d17c27a9cedb6001836534b81"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#a33d3e13d17c27a9cedb6001836534b81">read_some</a> (const MutableBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a33d3e13d17c27a9cedb6001836534b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data from the handle.  <a href="#a33d3e13d17c27a9cedb6001836534b81">More...</a><br /></td></tr>
<tr class="separator:a33d3e13d17c27a9cedb6001836534b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc437b2012e8cc8f39032d391a8e9470"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:adc437b2012e8cc8f39032d391a8e9470"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1stream__handle.html#adc437b2012e8cc8f39032d391a8e9470">async_read_some</a> (const MutableBufferSequence &amp;buffers, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:adc437b2012e8cc8f39032d391a8e9470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous read.  <a href="#adc437b2012e8cc8f39032d391a8e9470">More...</a><br /></td></tr>
<tr class="separator:adc437b2012e8cc8f39032d391a8e9470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee16ddf1feb9d2ae35253a562c18a6bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#aee16ddf1feb9d2ae35253a562c18a6bb">get_io_context</a> ()</td></tr>
<tr class="memdesc:aee16ddf1feb9d2ae35253a562c18a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a05aa7cb5159d6bcc55dc93c785e06b18" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object.  <a href="#aee16ddf1feb9d2ae35253a562c18a6bb">More...</a><br /></td></tr>
<tr class="separator:aee16ddf1feb9d2ae35253a562c18a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebf728b6a8393275bf66f240a9795f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a7ebf728b6a8393275bf66f240a9795f1">get_io_service</a> ()</td></tr>
<tr class="memdesc:a7ebf728b6a8393275bf66f240a9795f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a05aa7cb5159d6bcc55dc93c785e06b18" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object.  <a href="#a7ebf728b6a8393275bf66f240a9795f1">More...</a><br /></td></tr>
<tr class="separator:a7ebf728b6a8393275bf66f240a9795f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aa7cb5159d6bcc55dc93c785e06b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a15940b7e01577a37dc17aeb9dce6d2f0">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a05aa7cb5159d6bcc55dc93c785e06b18">get_executor</a> () noexcept</td></tr>
<tr class="memdesc:a05aa7cb5159d6bcc55dc93c785e06b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="#a05aa7cb5159d6bcc55dc93c785e06b18">More...</a><br /></td></tr>
<tr class="separator:a05aa7cb5159d6bcc55dc93c785e06b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a41985e09b088f99c6196da9de5f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a06a41985e09b088f99c6196da9de5f77">lowest_layer</a> ()</td></tr>
<tr class="memdesc:a06a41985e09b088f99c6196da9de5f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#a06a41985e09b088f99c6196da9de5f77">More...</a><br /></td></tr>
<tr class="separator:a06a41985e09b088f99c6196da9de5f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c992e9c4e1c5c81e4e804f1eaf330b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a03c992e9c4e1c5c81e4e804f1eaf330b">lowest_layer</a> () const</td></tr>
<tr class="memdesc:a03c992e9c4e1c5c81e4e804f1eaf330b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="#a03c992e9c4e1c5c81e4e804f1eaf330b">More...</a><br /></td></tr>
<tr class="separator:a03c992e9c4e1c5c81e4e804f1eaf330b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43240677ee4b3cd235f2faa02c0dcd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#af43240677ee4b3cd235f2faa02c0dcd5">assign</a> (const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;handle)</td></tr>
<tr class="memdesc:af43240677ee4b3cd235f2faa02c0dcd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native handle to the handle.  <a href="#af43240677ee4b3cd235f2faa02c0dcd5">More...</a><br /></td></tr>
<tr class="separator:af43240677ee4b3cd235f2faa02c0dcd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0108efc5dfcf4f96aead4748d9589e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#aa0108efc5dfcf4f96aead4748d9589e7">assign</a> (const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;handle, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa0108efc5dfcf4f96aead4748d9589e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign an existing native handle to the handle.  <a href="#aa0108efc5dfcf4f96aead4748d9589e7">More...</a><br /></td></tr>
<tr class="separator:aa0108efc5dfcf4f96aead4748d9589e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec132f4d65ce96ddca98f3ef2bba696"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a6ec132f4d65ce96ddca98f3ef2bba696">is_open</a> () const</td></tr>
<tr class="memdesc:a6ec132f4d65ce96ddca98f3ef2bba696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the handle is open.  <a href="#a6ec132f4d65ce96ddca98f3ef2bba696">More...</a><br /></td></tr>
<tr class="separator:a6ec132f4d65ce96ddca98f3ef2bba696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41abc9cb6503e6ec413cccb802089d2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a41abc9cb6503e6ec413cccb802089d2d">close</a> ()</td></tr>
<tr class="memdesc:a41abc9cb6503e6ec413cccb802089d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the handle.  <a href="#a41abc9cb6503e6ec413cccb802089d2d">More...</a><br /></td></tr>
<tr class="separator:a41abc9cb6503e6ec413cccb802089d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25225dac80a072abaf0be27f5438c65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ab25225dac80a072abaf0be27f5438c65">close</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ab25225dac80a072abaf0be27f5438c65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the handle.  <a href="#ab25225dac80a072abaf0be27f5438c65">More...</a><br /></td></tr>
<tr class="separator:ab25225dac80a072abaf0be27f5438c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2282eddc683a0ca0a820d96efc68c0ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a2282eddc683a0ca0a820d96efc68c0ef">native_handle</a> ()</td></tr>
<tr class="memdesc:a2282eddc683a0ca0a820d96efc68c0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native handle representation.  <a href="#a2282eddc683a0ca0a820d96efc68c0ef">More...</a><br /></td></tr>
<tr class="separator:a2282eddc683a0ca0a820d96efc68c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dd1ab618c6328e26025a325065aca5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ab7dd1ab618c6328e26025a325065aca5">cancel</a> ()</td></tr>
<tr class="memdesc:ab7dd1ab618c6328e26025a325065aca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the handle.  <a href="#ab7dd1ab618c6328e26025a325065aca5">More...</a><br /></td></tr>
<tr class="separator:ab7dd1ab618c6328e26025a325065aca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1510f92a5c00aed366b77d6a8d1b8076"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a1510f92a5c00aed366b77d6a8d1b8076">cancel</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a1510f92a5c00aed366b77d6a8d1b8076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the handle.  <a href="#a1510f92a5c00aed366b77d6a8d1b8076">More...</a><br /></td></tr>
<tr class="separator:a1510f92a5c00aed366b77d6a8d1b8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides stream-oriented handle functionality. </p>
<p>The <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">windows::stream_handle</a> class provides asynchronous and blocking stream-oriented handle functionality.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br />
<em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>AsyncReadStream, AsyncWriteStream, Stream, SyncReadStream, SyncWriteStream. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a15940b7e01577a37dc17aeb9dce6d2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15940b7e01577a37dc17aeb9dce6d2f0">&#9670;&nbsp;</a></span>executor_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context_1_1executor__type.html">io_context::executor_type</a> <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a15940b7e01577a37dc17aeb9dce6d2f0">asio::windows::overlapped_handle::executor_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

</div>
</div>
<a id="a0e1ebc42b9077ef7d88c62def4543e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1ebc42b9077ef7d88c62def4543e09">&#9670;&nbsp;</a></span>native_handle_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">asio::windows::overlapped_handle::native_handle_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The native representation of a handle. </p>

</div>
</div>
<a id="ac5aaeda5763f215bbca16fea1310579b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5aaeda5763f215bbca16fea1310579b">&#9670;&nbsp;</a></span>lowest_layer_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html">overlapped_handle</a> <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">asio::windows::overlapped_handle::lowest_layer_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html" title="Provides Windows handle functionality for objects that support overlapped I/O. ">overlapped_handle</a> is always the lowest layer. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acaf97eb9811a484a7a5c53ac02740108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf97eb9811a484a7a5c53ac02740108">&#9670;&nbsp;</a></span>stream_handle() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asio::windows::stream_handle::stream_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> without opening it. </p>
<p>This constructor creates a stream handle without opening it. The handle needs to be opened and then connected or accepted before data can be sent or received on it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the stream handle will use to dispatch handlers for any asynchronous operations performed on the handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8832a1118e1efbea1817d970fffb02f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8832a1118e1efbea1817d970fffb02f7">&#9670;&nbsp;</a></span>stream_handle() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::windows::stream_handle::stream_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> on an existing native handle. </p>
<p>This constructor creates a stream handle object to hold an existing native handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the stream handle will use to dispatch handlers for any asynchronous operations performed on the handle.</td></tr>
    <tr><td class="paramname">handle</td><td>The new underlying handle implementation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9db86488ae17ed99ae51102ffb755eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db86488ae17ed99ae51102ffb755eba">&#9670;&nbsp;</a></span>stream_handle() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">asio::windows::stream_handle::stream_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> from another. </p>
<p>This constructor moves a stream handle from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1windows_1_1stream__handle.html#acaf97eb9811a484a7a5c53ac02740108" title="Construct a stream_handle without opening it. ">stream_handle(io_context&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac8f1636b0f52c1a5ba1c7c8359d0598e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f1636b0f52c1a5ba1c7c8359d0598e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a>&amp; asio::windows::stream_handle::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1windows_1_1stream__handle.html">stream_handle</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-assign a <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> from another. </p>
<p>This assignment operator moves a stream handle from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1windows_1_1stream__handle.html" title="Provides stream-oriented handle functionality. ">stream_handle</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1windows_1_1stream__handle.html#acaf97eb9811a484a7a5c53ac02740108" title="Construct a stream_handle without opening it. ">stream_handle(io_context&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="a0dd56eef44470178c5e9b3229f4c87f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd56eef44470178c5e9b3229f4c87f8">&#9670;&nbsp;</a></span>write_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::windows::stream_handle::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write some data to the handle. </p>
<p>This function is used to write data to the stream handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. An error code of <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847abb0b3b47deff67dd67b180d9d1e34154" title="End of file or stream. ">asio::error::eof</a> indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">handle.write_some(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size));</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="a89c76234373f93409d2ea26fc545a6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c76234373f93409d2ea26fc545a6bc">&#9670;&nbsp;</a></span>write_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::windows::stream_handle::write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write some data to the handle. </p>
<p>This function is used to write data to the stream handle. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the handle.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The write_some operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__write.html">asio::write</a> function if you need to ensure that all data is written before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="a1b9dcca6383a4ec105611b705e57bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9dcca6383a4ec105611b705e57bb74">&#9670;&nbsp;</a></span>async_write_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConstBufferSequence , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::windows::stream_handle::async_write_some </td>
          <td>(</td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous write. </p>
<p>This function is used to asynchronously write data to the stream handle. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the handle. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes written.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The write operation may not transmit all of the data to the peer. Consider using the <a class="el" href="group__async__write.html">asio::async_write</a> function if you need to ensure that all data is written before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">handle.async_write_some(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size), handler);</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="a471fc09e50b701f10339c0b81579d699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471fc09e50b701f10339c0b81579d699">&#9670;&nbsp;</a></span>read_some() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::windows::stream_handle::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some data from the handle. </p>
<p>This function is used to read data from the stream handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. An error code of <a class="el" href="namespaceasio_1_1error.html#ade61a402d1dfb10b1c223906f5ea7847abb0b3b47deff67dd67b180d9d1e34154" title="End of file or stream. ">asio::error::eof</a> indicates that the connection was closed by the peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">handle.read_some(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size));</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="a33d3e13d17c27a9cedb6001836534b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d3e13d17c27a9cedb6001836534b81">&#9670;&nbsp;</a></span>read_some() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::windows::stream_handle::read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some data from the handle. </p>
<p>This function is used to read data from the stream handle. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The read_some operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__read.html">asio::read</a> function if you need to ensure that the requested amount of data is read before the blocking operation completes. </dd></dl>

</div>
</div>
<a id="adc437b2012e8cc8f39032d391a8e9470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc437b2012e8cc8f39032d391a8e9470">&#9670;&nbsp;</a></span>async_read_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutableBufferSequence , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::windows::stream_handle::async_read_some </td>
          <td>(</td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous read. </p>
<p>This function is used to asynchronously read data from the stream handle. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes read.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The read operation may not read all of the requested number of bytes. Consider using the <a class="el" href="group__async__read.html">asio::async_read</a> function if you need to ensure that the requested amount of data is read before the asynchronous operation completes.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line">handle.async_read_some(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size), handler);</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="aee16ddf1feb9d2ae35253a562c18a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee16ddf1feb9d2ae35253a562c18a6bb">&#9670;&nbsp;</a></span>get_io_context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a>&amp; asio::windows::overlapped_handle::get_io_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Deprecated: Use <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a05aa7cb5159d6bcc55dc93c785e06b18" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object. </p>
<p>This function may be used to obtain the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a7ebf728b6a8393275bf66f240a9795f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ebf728b6a8393275bf66f240a9795f1">&#9670;&nbsp;</a></span>get_io_service()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a>&amp; asio::windows::overlapped_handle::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Deprecated: Use <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a05aa7cb5159d6bcc55dc93c785e06b18" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object. </p>
<p>This function may be used to obtain the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a05aa7cb5159d6bcc55dc93c785e06b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aa7cb5159d6bcc55dc93c785e06b18">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a15940b7e01577a37dc17aeb9dce6d2f0">executor_type</a> asio::windows::overlapped_handle::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

</div>
</div>
<a id="a06a41985e09b088f99c6196da9de5f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a41985e09b088f99c6196da9de5f77">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">lowest_layer_type</a>&amp; asio::windows::overlapped_handle::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>
<p>This function returns a reference to the lowest layer in a stack of layers. Since an <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html" title="Provides Windows handle functionality for objects that support overlapped I/O. ">overlapped_handle</a> cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a03c992e9c4e1c5c81e4e804f1eaf330b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03c992e9c4e1c5c81e4e804f1eaf330b">&#9670;&nbsp;</a></span>lowest_layer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#ac5aaeda5763f215bbca16fea1310579b">lowest_layer_type</a>&amp; asio::windows::overlapped_handle::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>
<p>This function returns a const reference to the lowest layer in a stack of layers. Since an <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html" title="Provides Windows handle functionality for objects that support overlapped I/O. ">overlapped_handle</a> cannot contain any further layers, it simply returns a reference to itself.</p>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the lowest layer in the stack of layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="af43240677ee4b3cd235f2faa02c0dcd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43240677ee4b3cd235f2faa02c0dcd5">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native handle to the handle. </p>

</div>
</div>
<a id="aa0108efc5dfcf4f96aead4748d9589e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0108efc5dfcf4f96aead4748d9589e7">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign an existing native handle to the handle. </p>

</div>
</div>
<a id="a6ec132f4d65ce96ddca98f3ef2bba696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec132f4d65ce96ddca98f3ef2bba696">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::windows::overlapped_handle::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether the handle is open. </p>

</div>
</div>
<a id="a41abc9cb6503e6ec413cccb802089d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41abc9cb6503e6ec413cccb802089d2d">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the handle. </p>
<p>This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab25225dac80a072abaf0be27f5438c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25225dac80a072abaf0be27f5438c65">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Close the handle. </p>
<p>This function is used to close the handle. Any asynchronous read or write operations will be cancelled immediately, and will complete with the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2282eddc683a0ca0a820d96efc68c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2282eddc683a0ca0a820d96efc68c0ef">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1windows_1_1overlapped__handle.html#a0e1ebc42b9077ef7d88c62def4543e09">native_handle_type</a> asio::windows::overlapped_handle::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the native handle representation. </p>
<p>This function may be used to obtain the underlying representation of the handle. This is intended to allow access to native handle functionality that is not otherwise provided. </p>

</div>
</div>
<a id="ab7dd1ab618c6328e26025a325065aca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7dd1ab618c6328e26025a325065aca5">&#9670;&nbsp;</a></span>cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the handle. </p>
<p>This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1510f92a5c00aed366b77d6a8d1b8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1510f92a5c00aed366b77d6a8d1b8076">&#9670;&nbsp;</a></span>cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void asio::windows::overlapped_handle::cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the handle. </p>
<p>This function causes all outstanding asynchronous read or write operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
