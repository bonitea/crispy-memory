<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::basic_socket_acceptor&lt; Protocol &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasio.html">asio</a></li><li class="navelem"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classasio_1_1basic__socket__acceptor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asio::basic_socket_acceptor&lt; Protocol &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides the ability to accept new connections.  
 <a href="classasio_1_1basic__socket__acceptor.html#details">More...</a></p>

<p>Inherits ASIO_SVC_ACCESS basic_io_object&lt; asio::detail::service &gt;, and <a class="el" href="classasio_1_1socket__base.html">asio::socket_base</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a990444d2e4091b61e859baf9990be650"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context_1_1executor__type.html">io_context::executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a990444d2e4091b61e859baf9990be650">executor_type</a></td></tr>
<tr class="memdesc:a990444d2e4091b61e859baf9990be650"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the executor associated with the object.  <a href="#a990444d2e4091b61e859baf9990be650">More...</a><br /></td></tr>
<tr class="separator:a990444d2e4091b61e859baf9990be650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ba54a920426d82acdddd7094e451fa"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a></td></tr>
<tr class="memdesc:ab2ba54a920426d82acdddd7094e451fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The native representation of an acceptor.  <a href="#ab2ba54a920426d82acdddd7094e451fa">More...</a><br /></td></tr>
<tr class="separator:ab2ba54a920426d82acdddd7094e451fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca71bda7efef6da54ad711b7fd2222"><td class="memItemLeft" align="right" valign="top">typedef Protocol&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a></td></tr>
<tr class="memdesc:a33ca71bda7efef6da54ad711b7fd2222"><td class="mdescLeft">&#160;</td><td class="mdescRight">The protocol type.  <a href="#a33ca71bda7efef6da54ad711b7fd2222">More...</a><br /></td></tr>
<tr class="separator:a33ca71bda7efef6da54ad711b7fd2222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e07d5a917bd1fa5392fe648759a9746"><td class="memItemLeft" align="right" valign="top">typedef Protocol::endpoint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a></td></tr>
<tr class="memdesc:a7e07d5a917bd1fa5392fe648759a9746"><td class="mdescLeft">&#160;</td><td class="mdescRight">The endpoint type.  <a href="#a7e07d5a917bd1fa5392fe648759a9746">More...</a><br /></td></tr>
<tr class="separator:a7e07d5a917bd1fa5392fe648759a9746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915e52ff147efd296350bba81f795c37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37">shutdown_type</a> { <br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37acbfe078d69142138f3162984ba6a1b9b">shutdown_receive</a> = implementation_defined, 
<br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37a042d0121d26acaa45a86e0db3cb8aa62">shutdown_send</a> = implementation_defined, 
<br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37a66b86f5f0b2524bc7652dc9c7c82c0fd">shutdown_both</a> = implementation_defined
<br />
 }<tr class="memdesc:a915e52ff147efd296350bba81f795c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different ways a socket may be shutdown.  <a href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a915e52ff147efd296350bba81f795c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ecdd0897737c322ba27c6900205473"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a> { <br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473af1fa856779abbb3f088ea697401e8f9b">wait_read</a>, 
<br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473adbaf5ba901a18c5f8bf3ca2f9b995250">wait_write</a>, 
<br />
&#160;&#160;<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473afcdf41a7959efd856c2fc99f31903486">wait_error</a>
<br />
 }<tr class="memdesc:a93ecdd0897737c322ba27c6900205473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait types.  <a href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a93ecdd0897737c322ba27c6900205473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cf77465dfedfe1979b5415cf32cc94"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ac3cf77465dfedfe1979b5415cf32cc94">message_flags</a></td></tr>
<tr class="memdesc:ac3cf77465dfedfe1979b5415cf32cc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask type for flags that can be passed to send and receive operations.  <a href="#ac3cf77465dfedfe1979b5415cf32cc94">More...</a><br /></td></tr>
<tr class="separator:ac3cf77465dfedfe1979b5415cf32cc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee34d723e630ad0cc0b745ca5f6dc2ba"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#aee34d723e630ad0cc0b745ca5f6dc2ba">broadcast</a></td></tr>
<tr class="memdesc:aee34d723e630ad0cc0b745ca5f6dc2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to permit sending of broadcast messages.  <a href="#aee34d723e630ad0cc0b745ca5f6dc2ba">More...</a><br /></td></tr>
<tr class="separator:aee34d723e630ad0cc0b745ca5f6dc2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c3c8844bdf08f6f74fae000d6d7217"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ad2c3c8844bdf08f6f74fae000d6d7217">debug</a></td></tr>
<tr class="memdesc:ad2c3c8844bdf08f6f74fae000d6d7217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to enable socket-level debugging.  <a href="#ad2c3c8844bdf08f6f74fae000d6d7217">More...</a><br /></td></tr>
<tr class="separator:ad2c3c8844bdf08f6f74fae000d6d7217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4220b1b3fd7ca674d8adedb742d71680"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a4220b1b3fd7ca674d8adedb742d71680">do_not_route</a></td></tr>
<tr class="memdesc:a4220b1b3fd7ca674d8adedb742d71680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to prevent routing, use local interfaces only.  <a href="#a4220b1b3fd7ca674d8adedb742d71680">More...</a><br /></td></tr>
<tr class="separator:a4220b1b3fd7ca674d8adedb742d71680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493d09a6a851ec400a30e8f22adb9d74"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a493d09a6a851ec400a30e8f22adb9d74">keep_alive</a></td></tr>
<tr class="memdesc:a493d09a6a851ec400a30e8f22adb9d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to send keep-alives.  <a href="#a493d09a6a851ec400a30e8f22adb9d74">More...</a><br /></td></tr>
<tr class="separator:a493d09a6a851ec400a30e8f22adb9d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8869a31e4367e9b62c08609dc89591b2"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a8869a31e4367e9b62c08609dc89591b2">send_buffer_size</a></td></tr>
<tr class="memdesc:a8869a31e4367e9b62c08609dc89591b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option for the send buffer size of a socket.  <a href="#a8869a31e4367e9b62c08609dc89591b2">More...</a><br /></td></tr>
<tr class="separator:a8869a31e4367e9b62c08609dc89591b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff502237f6a2e248e68483e9ca6a0d2"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#abff502237f6a2e248e68483e9ca6a0d2">send_low_watermark</a></td></tr>
<tr class="memdesc:abff502237f6a2e248e68483e9ca6a0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option for the send low watermark.  <a href="#abff502237f6a2e248e68483e9ca6a0d2">More...</a><br /></td></tr>
<tr class="separator:abff502237f6a2e248e68483e9ca6a0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79401946636f3e91c1cc66436d1f975"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ad79401946636f3e91c1cc66436d1f975">receive_buffer_size</a></td></tr>
<tr class="memdesc:ad79401946636f3e91c1cc66436d1f975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option for the receive buffer size of a socket.  <a href="#ad79401946636f3e91c1cc66436d1f975">More...</a><br /></td></tr>
<tr class="separator:ad79401946636f3e91c1cc66436d1f975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af487bc8987ef57e2c7469b40bba591a3"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#af487bc8987ef57e2c7469b40bba591a3">receive_low_watermark</a></td></tr>
<tr class="memdesc:af487bc8987ef57e2c7469b40bba591a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option for the receive low watermark.  <a href="#af487bc8987ef57e2c7469b40bba591a3">More...</a><br /></td></tr>
<tr class="separator:af487bc8987ef57e2c7469b40bba591a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ab5649a23766107c5da2a04993d8dc"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc">reuse_address</a></td></tr>
<tr class="memdesc:a66ab5649a23766107c5da2a04993d8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to allow the socket to be bound to an address that is already in use.  <a href="#a66ab5649a23766107c5da2a04993d8dc">More...</a><br /></td></tr>
<tr class="separator:a66ab5649a23766107c5da2a04993d8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308e86dd1ee896dd26c07abf7e6ff1b5"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a308e86dd1ee896dd26c07abf7e6ff1b5">linger</a></td></tr>
<tr class="memdesc:a308e86dd1ee896dd26c07abf7e6ff1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to specify whether the socket lingers on close if unsent data is present.  <a href="#a308e86dd1ee896dd26c07abf7e6ff1b5">More...</a><br /></td></tr>
<tr class="separator:a308e86dd1ee896dd26c07abf7e6ff1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38622a265bda555107ce6d97bed8d739"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a38622a265bda555107ce6d97bed8d739">out_of_band_inline</a></td></tr>
<tr class="memdesc:a38622a265bda555107ce6d97bed8d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option for putting received out-of-band data inline.  <a href="#a38622a265bda555107ce6d97bed8d739">More...</a><br /></td></tr>
<tr class="separator:a38622a265bda555107ce6d97bed8d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef00aa2ca23006e9868f2ea46223aea"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a9ef00aa2ca23006e9868f2ea46223aea">enable_connection_aborted</a></td></tr>
<tr class="memdesc:a9ef00aa2ca23006e9868f2ea46223aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket option to report aborted connections on accept.  <a href="#a9ef00aa2ca23006e9868f2ea46223aea">More...</a><br /></td></tr>
<tr class="separator:a9ef00aa2ca23006e9868f2ea46223aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbde8e590fbb98dfa1685b9d435cb5dc"><td class="memItemLeft" align="right" valign="top">typedef implementation_defined&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#abbde8e590fbb98dfa1685b9d435cb5dc">bytes_readable</a></td></tr>
<tr class="memdesc:abbde8e590fbb98dfa1685b9d435cb5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">IO control command to get the amount of data that can be read without blocking.  <a href="#abbde8e590fbb98dfa1685b9d435cb5dc">More...</a><br /></td></tr>
<tr class="separator:abbde8e590fbb98dfa1685b9d435cb5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a55e23f093c1f957fa0cd77bd30978b93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a55e23f093c1f957fa0cd77bd30978b93">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>)</td></tr>
<tr class="memdesc:a55e23f093c1f957fa0cd77bd30978b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an acceptor without opening it.  <a href="#a55e23f093c1f957fa0cd77bd30978b93">More...</a><br /></td></tr>
<tr class="separator:a55e23f093c1f957fa0cd77bd30978b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac112e0d4bde0de5fe5193d52bf477efa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ac112e0d4bde0de5fe5193d52bf477efa">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol)</td></tr>
<tr class="memdesc:ac112e0d4bde0de5fe5193d52bf477efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an open acceptor.  <a href="#ac112e0d4bde0de5fe5193d52bf477efa">More...</a><br /></td></tr>
<tr class="separator:ac112e0d4bde0de5fe5193d52bf477efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae538b2481895eaa9283c651aa5b16e6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae538b2481895eaa9283c651aa5b16e6f">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;endpoint, bool reuse_addr=true)</td></tr>
<tr class="memdesc:ae538b2481895eaa9283c651aa5b16e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an acceptor opened on the given endpoint.  <a href="#ae538b2481895eaa9283c651aa5b16e6f">More...</a><br /></td></tr>
<tr class="separator:ae538b2481895eaa9283c651aa5b16e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00dbd4d350fa20c4291a157a904ed1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab00dbd4d350fa20c4291a157a904ed1e">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;native_acceptor)</td></tr>
<tr class="memdesc:ab00dbd4d350fa20c4291a157a904ed1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> on an existing native acceptor.  <a href="#ab00dbd4d350fa20c4291a157a904ed1e">More...</a><br /></td></tr>
<tr class="separator:ab00dbd4d350fa20c4291a157a904ed1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a01f1178d21df1d93f1e6ecabe0167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ad0a01f1178d21df1d93f1e6ecabe0167">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:ad0a01f1178d21df1d93f1e6ecabe0167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from another.  <a href="#ad0a01f1178d21df1d93f1e6ecabe0167">More...</a><br /></td></tr>
<tr class="separator:ad0a01f1178d21df1d93f1e6ecabe0167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1867a3218bc3b4b69987e365f587ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9c1867a3218bc3b4b69987e365f587ae">operator=</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a9c1867a3218bc3b4b69987e365f587ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from another.  <a href="#a9c1867a3218bc3b4b69987e365f587ae">More...</a><br /></td></tr>
<tr class="separator:a9c1867a3218bc3b4b69987e365f587ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde4cf212a1d9cd2012971c55ca3ca2c"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 &gt; </td></tr>
<tr class="memitem:acde4cf212a1d9cd2012971c55ca3ca2c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#acde4cf212a1d9cd2012971c55ca3ca2c">basic_socket_acceptor</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol1 &gt; &amp;&amp;other, typename enable_if&lt; is_convertible&lt; Protocol1, Protocol &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:acde4cf212a1d9cd2012971c55ca3ca2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from an acceptor of another protocol type.  <a href="#acde4cf212a1d9cd2012971c55ca3ca2c">More...</a><br /></td></tr>
<tr class="separator:acde4cf212a1d9cd2012971c55ca3ca2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e593fce13b015b599ad57590e28d4bf"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 &gt; </td></tr>
<tr class="memitem:a3e593fce13b015b599ad57590e28d4bf"><td class="memTemplItemLeft" align="right" valign="top">enable_if&lt; is_convertible&lt; Protocol1, Protocol &gt;::value, <a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a3e593fce13b015b599ad57590e28d4bf">operator=</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol1 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a3e593fce13b015b599ad57590e28d4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from an acceptor of another protocol type.  <a href="#a3e593fce13b015b599ad57590e28d4bf">More...</a><br /></td></tr>
<tr class="separator:a3e593fce13b015b599ad57590e28d4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c9b82fcc5bdee7c2a855d13c68a078"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ac5c9b82fcc5bdee7c2a855d13c68a078">~basic_socket_acceptor</a> ()</td></tr>
<tr class="memdesc:ac5c9b82fcc5bdee7c2a855d13c68a078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the acceptor.  <a href="#ac5c9b82fcc5bdee7c2a855d13c68a078">More...</a><br /></td></tr>
<tr class="separator:ac5c9b82fcc5bdee7c2a855d13c68a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079765bc41659ceebe0f234bffa3d1fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a079765bc41659ceebe0f234bffa3d1fc">get_io_context</a> ()</td></tr>
<tr class="memdesc:a079765bc41659ceebe0f234bffa3d1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1basic__socket__acceptor.html#afd3b6aad87e62c6807f468b04528cdcf" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object.  <a href="#a079765bc41659ceebe0f234bffa3d1fc">More...</a><br /></td></tr>
<tr class="separator:a079765bc41659ceebe0f234bffa3d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8880ec61ec174c58019375519fc4fb40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a8880ec61ec174c58019375519fc4fb40">get_io_service</a> ()</td></tr>
<tr class="memdesc:a8880ec61ec174c58019375519fc4fb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1basic__socket__acceptor.html#afd3b6aad87e62c6807f468b04528cdcf" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object.  <a href="#a8880ec61ec174c58019375519fc4fb40">More...</a><br /></td></tr>
<tr class="separator:a8880ec61ec174c58019375519fc4fb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b6aad87e62c6807f468b04528cdcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a990444d2e4091b61e859baf9990be650">executor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#afd3b6aad87e62c6807f468b04528cdcf">get_executor</a> () noexcept</td></tr>
<tr class="memdesc:afd3b6aad87e62c6807f468b04528cdcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the executor associated with the object.  <a href="#afd3b6aad87e62c6807f468b04528cdcf">More...</a><br /></td></tr>
<tr class="separator:afd3b6aad87e62c6807f468b04528cdcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b28c14b1b10df9cd0b82e3d489782a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a26b28c14b1b10df9cd0b82e3d489782a">open</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol=<a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a>())</td></tr>
<tr class="memdesc:a26b28c14b1b10df9cd0b82e3d489782a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the acceptor using the specified protocol.  <a href="#a26b28c14b1b10df9cd0b82e3d489782a">More...</a><br /></td></tr>
<tr class="separator:a26b28c14b1b10df9cd0b82e3d489782a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833c3c5271ac8f863d443578a983e751"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a833c3c5271ac8f863d443578a983e751">open</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a833c3c5271ac8f863d443578a983e751"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the acceptor using the specified protocol.  <a href="#a833c3c5271ac8f863d443578a983e751">More...</a><br /></td></tr>
<tr class="separator:a833c3c5271ac8f863d443578a983e751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d729725e46ee4c959583e30b4fc7ba6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a2d729725e46ee4c959583e30b4fc7ba6">assign</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;native_acceptor)</td></tr>
<tr class="memdesc:a2d729725e46ee4c959583e30b4fc7ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an existing native acceptor to the acceptor.  <a href="#a2d729725e46ee4c959583e30b4fc7ba6">More...</a><br /></td></tr>
<tr class="separator:a2d729725e46ee4c959583e30b4fc7ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970022c0898229ab455c7a1b6cc22a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9970022c0898229ab455c7a1b6cc22a1">assign</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;protocol, const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;native_acceptor, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a9970022c0898229ab455c7a1b6cc22a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns an existing native acceptor to the acceptor.  <a href="#a9970022c0898229ab455c7a1b6cc22a1">More...</a><br /></td></tr>
<tr class="separator:a9970022c0898229ab455c7a1b6cc22a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb3a8b87f8991e07aa1e307be5d5be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aa1eb3a8b87f8991e07aa1e307be5d5be">is_open</a> () const</td></tr>
<tr class="memdesc:aa1eb3a8b87f8991e07aa1e307be5d5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the acceptor is open.  <a href="#aa1eb3a8b87f8991e07aa1e307be5d5be">More...</a><br /></td></tr>
<tr class="separator:aa1eb3a8b87f8991e07aa1e307be5d5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae864f92000099822824daaf54ebe0775"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae864f92000099822824daaf54ebe0775">bind</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;endpoint)</td></tr>
<tr class="memdesc:ae864f92000099822824daaf54ebe0775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the acceptor to the given local endpoint.  <a href="#ae864f92000099822824daaf54ebe0775">More...</a><br /></td></tr>
<tr class="separator:ae864f92000099822824daaf54ebe0775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7a36634808ef33cc76aa389d66913d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aec7a36634808ef33cc76aa389d66913d">bind</a> (const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;endpoint, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aec7a36634808ef33cc76aa389d66913d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the acceptor to the given local endpoint.  <a href="#aec7a36634808ef33cc76aa389d66913d">More...</a><br /></td></tr>
<tr class="separator:aec7a36634808ef33cc76aa389d66913d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23fc2d25ba6a3b24f5207342574c467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#af23fc2d25ba6a3b24f5207342574c467">listen</a> (int backlog=<a class="el" href="classasio_1_1socket__base.html#a52b79fd51640a1a2ee3baed5f897a674">socket_base::max_listen_connections</a>)</td></tr>
<tr class="memdesc:af23fc2d25ba6a3b24f5207342574c467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place the acceptor into the state where it will listen for new connections.  <a href="#af23fc2d25ba6a3b24f5207342574c467">More...</a><br /></td></tr>
<tr class="separator:af23fc2d25ba6a3b24f5207342574c467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fcdb899768b9875dd901785d1358b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a86fcdb899768b9875dd901785d1358b1">listen</a> (int backlog, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a86fcdb899768b9875dd901785d1358b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Place the acceptor into the state where it will listen for new connections.  <a href="#a86fcdb899768b9875dd901785d1358b1">More...</a><br /></td></tr>
<tr class="separator:a86fcdb899768b9875dd901785d1358b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15976cd1f2861d9a2c622b9285a04be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#af15976cd1f2861d9a2c622b9285a04be">close</a> ()</td></tr>
<tr class="memdesc:af15976cd1f2861d9a2c622b9285a04be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the acceptor.  <a href="#af15976cd1f2861d9a2c622b9285a04be">More...</a><br /></td></tr>
<tr class="separator:af15976cd1f2861d9a2c622b9285a04be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa654ec70ffe0dc59f755dcfaa59d0e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aa654ec70ffe0dc59f755dcfaa59d0e22">close</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa654ec70ffe0dc59f755dcfaa59d0e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the acceptor.  <a href="#aa654ec70ffe0dc59f755dcfaa59d0e22">More...</a><br /></td></tr>
<tr class="separator:aa654ec70ffe0dc59f755dcfaa59d0e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9b422aa5cf1782e8a1df888fe5e8ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#add9b422aa5cf1782e8a1df888fe5e8ef">release</a> ()</td></tr>
<tr class="memdesc:add9b422aa5cf1782e8a1df888fe5e8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native acceptor.  <a href="#add9b422aa5cf1782e8a1df888fe5e8ef">More...</a><br /></td></tr>
<tr class="separator:add9b422aa5cf1782e8a1df888fe5e8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b7f16c397b76f2fdd05b757539622c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aa4b7f16c397b76f2fdd05b757539622c">release</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa4b7f16c397b76f2fdd05b757539622c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release ownership of the underlying native acceptor.  <a href="#aa4b7f16c397b76f2fdd05b757539622c">More...</a><br /></td></tr>
<tr class="separator:aa4b7f16c397b76f2fdd05b757539622c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa627d7f63e07c125b7b12c679b5b3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#afa627d7f63e07c125b7b12c679b5b3a1">native_handle</a> ()</td></tr>
<tr class="memdesc:afa627d7f63e07c125b7b12c679b5b3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native acceptor representation.  <a href="#afa627d7f63e07c125b7b12c679b5b3a1">More...</a><br /></td></tr>
<tr class="separator:afa627d7f63e07c125b7b12c679b5b3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e99268148000d633db4f9d9ab5c9ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a49e99268148000d633db4f9d9ab5c9ff">cancel</a> ()</td></tr>
<tr class="memdesc:a49e99268148000d633db4f9d9ab5c9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the acceptor.  <a href="#a49e99268148000d633db4f9d9ab5c9ff">More...</a><br /></td></tr>
<tr class="separator:a49e99268148000d633db4f9d9ab5c9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7834c3851f3264ef4f5dbaba78d8135b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7834c3851f3264ef4f5dbaba78d8135b">cancel</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a7834c3851f3264ef4f5dbaba78d8135b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all asynchronous operations associated with the acceptor.  <a href="#a7834c3851f3264ef4f5dbaba78d8135b">More...</a><br /></td></tr>
<tr class="separator:a7834c3851f3264ef4f5dbaba78d8135b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd972c85115ae7835197a2083bbf3395"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:abd972c85115ae7835197a2083bbf3395"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#abd972c85115ae7835197a2083bbf3395">set_option</a> (const SettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:abd972c85115ae7835197a2083bbf3395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the acceptor.  <a href="#abd972c85115ae7835197a2083bbf3395">More...</a><br /></td></tr>
<tr class="separator:abd972c85115ae7835197a2083bbf3395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32068c807816c25a4dc571f94330588"><td class="memTemplParams" colspan="2">template&lt;typename SettableSocketOption &gt; </td></tr>
<tr class="memitem:ad32068c807816c25a4dc571f94330588"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ad32068c807816c25a4dc571f94330588">set_option</a> (const SettableSocketOption &amp;option, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ad32068c807816c25a4dc571f94330588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an option on the acceptor.  <a href="#ad32068c807816c25a4dc571f94330588">More...</a><br /></td></tr>
<tr class="separator:ad32068c807816c25a4dc571f94330588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ab106c15bb49801b6322a27564a861"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a43ab106c15bb49801b6322a27564a861"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a43ab106c15bb49801b6322a27564a861">get_option</a> (GettableSocketOption &amp;option)</td></tr>
<tr class="memdesc:a43ab106c15bb49801b6322a27564a861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the acceptor.  <a href="#a43ab106c15bb49801b6322a27564a861">More...</a><br /></td></tr>
<tr class="separator:a43ab106c15bb49801b6322a27564a861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b96dffa39e583e0fd34c23f8086bc3"><td class="memTemplParams" colspan="2">template&lt;typename GettableSocketOption &gt; </td></tr>
<tr class="memitem:a78b96dffa39e583e0fd34c23f8086bc3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a78b96dffa39e583e0fd34c23f8086bc3">get_option</a> (GettableSocketOption &amp;option, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a78b96dffa39e583e0fd34c23f8086bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an option from the acceptor.  <a href="#a78b96dffa39e583e0fd34c23f8086bc3">More...</a><br /></td></tr>
<tr class="separator:a78b96dffa39e583e0fd34c23f8086bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2df51acdf2d3b13237b6a607384d2e"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a9d2df51acdf2d3b13237b6a607384d2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9d2df51acdf2d3b13237b6a607384d2e">io_control</a> (IoControlCommand &amp;command)</td></tr>
<tr class="memdesc:a9d2df51acdf2d3b13237b6a607384d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the acceptor.  <a href="#a9d2df51acdf2d3b13237b6a607384d2e">More...</a><br /></td></tr>
<tr class="separator:a9d2df51acdf2d3b13237b6a607384d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d44624abcfe22046b2176663ca19905"><td class="memTemplParams" colspan="2">template&lt;typename IoControlCommand &gt; </td></tr>
<tr class="memitem:a4d44624abcfe22046b2176663ca19905"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a4d44624abcfe22046b2176663ca19905">io_control</a> (IoControlCommand &amp;command, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a4d44624abcfe22046b2176663ca19905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform an IO control command on the acceptor.  <a href="#a4d44624abcfe22046b2176663ca19905">More...</a><br /></td></tr>
<tr class="separator:a4d44624abcfe22046b2176663ca19905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c0466b8b4173e732c9a90f14ce0f0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae7c0466b8b4173e732c9a90f14ce0f0e">non_blocking</a> () const</td></tr>
<tr class="memdesc:ae7c0466b8b4173e732c9a90f14ce0f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the acceptor.  <a href="#ae7c0466b8b4173e732c9a90f14ce0f0e">More...</a><br /></td></tr>
<tr class="separator:ae7c0466b8b4173e732c9a90f14ce0f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566c33543bf3ef9ffe19764e97563e66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a566c33543bf3ef9ffe19764e97563e66">non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a566c33543bf3ef9ffe19764e97563e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the acceptor.  <a href="#a566c33543bf3ef9ffe19764e97563e66">More...</a><br /></td></tr>
<tr class="separator:a566c33543bf3ef9ffe19764e97563e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2593d091fe5623d93d8dc49b0a9bd1db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a2593d091fe5623d93d8dc49b0a9bd1db">non_blocking</a> (bool mode, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a2593d091fe5623d93d8dc49b0a9bd1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the acceptor.  <a href="#a2593d091fe5623d93d8dc49b0a9bd1db">More...</a><br /></td></tr>
<tr class="separator:a2593d091fe5623d93d8dc49b0a9bd1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9051a34a5b4620378865f74c0be293c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9051a34a5b4620378865f74c0be293c8">native_non_blocking</a> () const</td></tr>
<tr class="memdesc:a9051a34a5b4620378865f74c0be293c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the non-blocking mode of the native acceptor implementation.  <a href="#a9051a34a5b4620378865f74c0be293c8">More...</a><br /></td></tr>
<tr class="separator:a9051a34a5b4620378865f74c0be293c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f25aca0ed3dacc5dd6e760d442e99cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a1f25aca0ed3dacc5dd6e760d442e99cd">native_non_blocking</a> (bool mode)</td></tr>
<tr class="memdesc:a1f25aca0ed3dacc5dd6e760d442e99cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native acceptor implementation.  <a href="#a1f25aca0ed3dacc5dd6e760d442e99cd">More...</a><br /></td></tr>
<tr class="separator:a1f25aca0ed3dacc5dd6e760d442e99cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a797d78c62bd7778dd7f33a3af1d5ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a0a797d78c62bd7778dd7f33a3af1d5ae">native_non_blocking</a> (bool mode, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a0a797d78c62bd7778dd7f33a3af1d5ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the non-blocking mode of the native acceptor implementation.  <a href="#a0a797d78c62bd7778dd7f33a3af1d5ae">More...</a><br /></td></tr>
<tr class="separator:a0a797d78c62bd7778dd7f33a3af1d5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9852bcfd2882c59be8c21dffccfd77da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9852bcfd2882c59be8c21dffccfd77da">local_endpoint</a> () const</td></tr>
<tr class="memdesc:a9852bcfd2882c59be8c21dffccfd77da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the acceptor.  <a href="#a9852bcfd2882c59be8c21dffccfd77da">More...</a><br /></td></tr>
<tr class="separator:a9852bcfd2882c59be8c21dffccfd77da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51562b7296a6cbcaa446b514b8c54019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a51562b7296a6cbcaa446b514b8c54019">local_endpoint</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec) const</td></tr>
<tr class="memdesc:a51562b7296a6cbcaa446b514b8c54019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local endpoint of the acceptor.  <a href="#a51562b7296a6cbcaa446b514b8c54019">More...</a><br /></td></tr>
<tr class="separator:a51562b7296a6cbcaa446b514b8c54019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76a707af7e819077c155780a7c962a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aa76a707af7e819077c155780a7c962a0">wait</a> (<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a> w)</td></tr>
<tr class="memdesc:aa76a707af7e819077c155780a7c962a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions.  <a href="#aa76a707af7e819077c155780a7c962a0">More...</a><br /></td></tr>
<tr class="separator:aa76a707af7e819077c155780a7c962a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae15a6c5b9001970c31b70d7bfac9be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9ae15a6c5b9001970c31b70d7bfac9be">wait</a> (<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a> w, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a9ae15a6c5b9001970c31b70d7bfac9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions.  <a href="#a9ae15a6c5b9001970c31b70d7bfac9be">More...</a><br /></td></tr>
<tr class="separator:a9ae15a6c5b9001970c31b70d7bfac9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40abf261e0fa367b2c37fa0fc54c3374"><td class="memTemplParams" colspan="2">template&lt;typename WaitHandler &gt; </td></tr>
<tr class="memitem:a40abf261e0fa367b2c37fa0fc54c3374"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a40abf261e0fa367b2c37fa0fc54c3374">async_wait</a> (<a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a> w, WaitHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a40abf261e0fa367b2c37fa0fc54c3374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions.  <a href="#a40abf261e0fa367b2c37fa0fc54c3374">More...</a><br /></td></tr>
<tr class="separator:a40abf261e0fa367b2c37fa0fc54c3374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173775e7f30cd7f1f781cb052c8dbf00"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 &gt; </td></tr>
<tr class="memitem:a173775e7f30cd7f1f781cb052c8dbf00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a173775e7f30cd7f1f781cb052c8dbf00">accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;peer, typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a173775e7f30cd7f1f781cb052c8dbf00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a173775e7f30cd7f1f781cb052c8dbf00">More...</a><br /></td></tr>
<tr class="separator:a173775e7f30cd7f1f781cb052c8dbf00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b188e244f79a7949a6b1e91987eb19"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 &gt; </td></tr>
<tr class="memitem:ae9b188e244f79a7949a6b1e91987eb19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae9b188e244f79a7949a6b1e91987eb19">accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;peer, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ae9b188e244f79a7949a6b1e91987eb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#ae9b188e244f79a7949a6b1e91987eb19">More...</a><br /></td></tr>
<tr class="separator:ae9b188e244f79a7949a6b1e91987eb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225dfadc107aa7d7f8ff1d5cbf43d377"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 , typename AcceptHandler &gt; </td></tr>
<tr class="memitem:a225dfadc107aa7d7f8ff1d5cbf43d377"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a225dfadc107aa7d7f8ff1d5cbf43d377">async_accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;peer, AcceptHandler &amp;&amp;handler, typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a225dfadc107aa7d7f8ff1d5cbf43d377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#a225dfadc107aa7d7f8ff1d5cbf43d377">More...</a><br /></td></tr>
<tr class="separator:a225dfadc107aa7d7f8ff1d5cbf43d377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899f093d3e4eec39c47ce8f7397b1611"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a899f093d3e4eec39c47ce8f7397b1611">accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;peer, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a899f093d3e4eec39c47ce8f7397b1611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection and obtain the endpoint of the peer.  <a href="#a899f093d3e4eec39c47ce8f7397b1611">More...</a><br /></td></tr>
<tr class="separator:a899f093d3e4eec39c47ce8f7397b1611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa704547d75b5336438f62ee5bf4e1d9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aa704547d75b5336438f62ee5bf4e1d9f">accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;peer, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:aa704547d75b5336438f62ee5bf4e1d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection and obtain the endpoint of the peer.  <a href="#aa704547d75b5336438f62ee5bf4e1d9f">More...</a><br /></td></tr>
<tr class="separator:aa704547d75b5336438f62ee5bf4e1d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4557677655d9a7cd1db84409fb807e"><td class="memTemplParams" colspan="2">template&lt;typename AcceptHandler &gt; </td></tr>
<tr class="memitem:aeb4557677655d9a7cd1db84409fb807e"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#aeb4557677655d9a7cd1db84409fb807e">async_accept</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;peer, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:aeb4557677655d9a7cd1db84409fb807e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#aeb4557677655d9a7cd1db84409fb807e">More...</a><br /></td></tr>
<tr class="separator:aeb4557677655d9a7cd1db84409fb807e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e7ddfbe5c0a00e4e490e9549e8c2bf"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab4e7ddfbe5c0a00e4e490e9549e8c2bf">accept</a> ()</td></tr>
<tr class="memdesc:ab4e7ddfbe5c0a00e4e490e9549e8c2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#ab4e7ddfbe5c0a00e4e490e9549e8c2bf">More...</a><br /></td></tr>
<tr class="separator:ab4e7ddfbe5c0a00e4e490e9549e8c2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279d30b9a66c9a758d3ce029431463a4"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a279d30b9a66c9a758d3ce029431463a4">accept</a> (<a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a279d30b9a66c9a758d3ce029431463a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a279d30b9a66c9a758d3ce029431463a4">More...</a><br /></td></tr>
<tr class="separator:a279d30b9a66c9a758d3ce029431463a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6e36dfed58f611a767c3898c5f32fa"><td class="memTemplParams" colspan="2">template&lt;typename MoveAcceptHandler &gt; </td></tr>
<tr class="memitem:a4a6e36dfed58f611a767c3898c5f32fa"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a4a6e36dfed58f611a767c3898c5f32fa">async_accept</a> (MoveAcceptHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a4a6e36dfed58f611a767c3898c5f32fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#a4a6e36dfed58f611a767c3898c5f32fa">More...</a><br /></td></tr>
<tr class="separator:a4a6e36dfed58f611a767c3898c5f32fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db636445be89426c61abfe8bf734462"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a5db636445be89426c61abfe8bf734462">accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>)</td></tr>
<tr class="memdesc:a5db636445be89426c61abfe8bf734462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a5db636445be89426c61abfe8bf734462">More...</a><br /></td></tr>
<tr class="separator:a5db636445be89426c61abfe8bf734462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d11d23f0909e3d6f795f54b0ceaac3"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ac3d11d23f0909e3d6f795f54b0ceaac3">accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ac3d11d23f0909e3d6f795f54b0ceaac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#ac3d11d23f0909e3d6f795f54b0ceaac3">More...</a><br /></td></tr>
<tr class="separator:ac3d11d23f0909e3d6f795f54b0ceaac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433977dfe2781e74d5990369515d8676"><td class="memTemplParams" colspan="2">template&lt;typename MoveAcceptHandler &gt; </td></tr>
<tr class="memitem:a433977dfe2781e74d5990369515d8676"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a433977dfe2781e74d5990369515d8676">async_accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, MoveAcceptHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a433977dfe2781e74d5990369515d8676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#a433977dfe2781e74d5990369515d8676">More...</a><br /></td></tr>
<tr class="separator:a433977dfe2781e74d5990369515d8676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b376b38018d85c0fdb92067cc91b797"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a2b376b38018d85c0fdb92067cc91b797">accept</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:a2b376b38018d85c0fdb92067cc91b797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a2b376b38018d85c0fdb92067cc91b797">More...</a><br /></td></tr>
<tr class="separator:a2b376b38018d85c0fdb92067cc91b797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb6870e2e1683985d59d5f17feb509e"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a1bb6870e2e1683985d59d5f17feb509e">accept</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a1bb6870e2e1683985d59d5f17feb509e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a1bb6870e2e1683985d59d5f17feb509e">More...</a><br /></td></tr>
<tr class="separator:a1bb6870e2e1683985d59d5f17feb509e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62733167c135f18d91181b6b84f4f415"><td class="memTemplParams" colspan="2">template&lt;typename MoveAcceptHandler &gt; </td></tr>
<tr class="memitem:a62733167c135f18d91181b6b84f4f415"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a62733167c135f18d91181b6b84f4f415">async_accept</a> (<a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, MoveAcceptHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:a62733167c135f18d91181b6b84f4f415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#a62733167c135f18d91181b6b84f4f415">More...</a><br /></td></tr>
<tr class="separator:a62733167c135f18d91181b6b84f4f415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1bef5bbc23f91deb6468976044a5af2"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab1bef5bbc23f91deb6468976044a5af2">accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint)</td></tr>
<tr class="memdesc:ab1bef5bbc23f91deb6468976044a5af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#ab1bef5bbc23f91deb6468976044a5af2">More...</a><br /></td></tr>
<tr class="separator:ab1bef5bbc23f91deb6468976044a5af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9753590b4d69d74853864884460a0240"><td class="memItemLeft" align="right" valign="top">Protocol::socket&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a9753590b4d69d74853864884460a0240">accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a9753590b4d69d74853864884460a0240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accept a new connection.  <a href="#a9753590b4d69d74853864884460a0240">More...</a><br /></td></tr>
<tr class="separator:a9753590b4d69d74853864884460a0240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add007866bac2a91fd8b9e31d5143b2dc"><td class="memTemplParams" colspan="2">template&lt;typename MoveAcceptHandler &gt; </td></tr>
<tr class="memitem:add007866bac2a91fd8b9e31d5143b2dc"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#add007866bac2a91fd8b9e31d5143b2dc">async_accept</a> (<a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;<a class="el" href="classasio_1_1io__context.html">io_context</a>, <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;peer_endpoint, MoveAcceptHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:add007866bac2a91fd8b9e31d5143b2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous accept.  <a href="#add007866bac2a91fd8b9e31d5143b2dc">More...</a><br /></td></tr>
<tr class="separator:add007866bac2a91fd8b9e31d5143b2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a356e1bd7da0353e5472028cdec742ed0"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a356e1bd7da0353e5472028cdec742ed0">message_peek</a> = implementation_defined</td></tr>
<tr class="memdesc:a356e1bd7da0353e5472028cdec742ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peek at incoming data without removing it from the input queue.  <a href="#a356e1bd7da0353e5472028cdec742ed0">More...</a><br /></td></tr>
<tr class="separator:a356e1bd7da0353e5472028cdec742ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f08ba445b7ce09ece5ac7beaa6e7c9"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ab9f08ba445b7ce09ece5ac7beaa6e7c9">message_out_of_band</a> = implementation_defined</td></tr>
<tr class="memdesc:ab9f08ba445b7ce09ece5ac7beaa6e7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process out-of-band data.  <a href="#ab9f08ba445b7ce09ece5ac7beaa6e7c9">More...</a><br /></td></tr>
<tr class="separator:ab9f08ba445b7ce09ece5ac7beaa6e7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27428a48d1a7113a95ea205b1e17978"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ae27428a48d1a7113a95ea205b1e17978">message_do_not_route</a> = implementation_defined</td></tr>
<tr class="memdesc:ae27428a48d1a7113a95ea205b1e17978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify that the data should not be subject to routing.  <a href="#ae27428a48d1a7113a95ea205b1e17978">More...</a><br /></td></tr>
<tr class="separator:ae27428a48d1a7113a95ea205b1e17978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1439c2255d52f1ec68da5fa3f40ee1"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#ade1439c2255d52f1ec68da5fa3f40ee1">message_end_of_record</a> = implementation_defined</td></tr>
<tr class="memdesc:ade1439c2255d52f1ec68da5fa3f40ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the data marks the end of a record.  <a href="#ade1439c2255d52f1ec68da5fa3f40ee1">More...</a><br /></td></tr>
<tr class="separator:ade1439c2255d52f1ec68da5fa3f40ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b79fd51640a1a2ee3baed5f897a674"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a52b79fd51640a1a2ee3baed5f897a674">max_listen_connections</a> = implementation_defined</td></tr>
<tr class="memdesc:a52b79fd51640a1a2ee3baed5f897a674"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum length of the queue of pending incoming connections.  <a href="#a52b79fd51640a1a2ee3baed5f897a674">More...</a><br /></td></tr>
<tr class="separator:a52b79fd51640a1a2ee3baed5f897a674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ee2a3ce0ec68ac8c026884c5bd3098"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html#a85ee2a3ce0ec68ac8c026884c5bd3098">max_connections</a> = implementation_defined</td></tr>
<tr class="memdesc:a85ee2a3ce0ec68ac8c026884c5bd3098"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections.  <a href="#a85ee2a3ce0ec68ac8c026884c5bd3098">More...</a><br /></td></tr>
<tr class="separator:a85ee2a3ce0ec68ac8c026884c5bd3098"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae6f984a5196e3773bb097fcd759982da"><td class="memTemplParams" colspan="2">template&lt;typename Protocol1 &gt; </td></tr>
<tr class="memitem:ae6f984a5196e3773bb097fcd759982da"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae6f984a5196e3773bb097fcd759982da">basic_socket_acceptor</a></td></tr>
<tr class="separator:ae6f984a5196e3773bb097fcd759982da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Protocol&gt;<br />
class asio::basic_socket_acceptor&lt; Protocol &gt;</h3>

<p>Provides the ability to accept new connections. </p>
<p>The <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> class template is used for accepting new socket connections.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br />
<em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Opening a socket acceptor with the SO_REUSEADDR option enabled: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>(<a class="code" href="classasio_1_1ip_1_1tcp.html#a5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), port);</div><div class="line">acceptor.open(endpoint.<a class="code" href="classasio_1_1ip_1_1basic__endpoint.html#aa9c4d0afb36a788547d8610722627446">protocol</a>());</div><div class="line">acceptor.set_option(<a class="code" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc">asio::ip::tcp::acceptor::reuse_address</a>(<span class="keyword">true</span>));</div><div class="line">acceptor.bind(endpoint);</div><div class="line">acceptor.listen();</div></div><!-- fragment --> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a990444d2e4091b61e859baf9990be650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990444d2e4091b61e859baf9990be650">&#9670;&nbsp;</a></span>executor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context_1_1executor__type.html">io_context::executor_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html#a990444d2e4091b61e859baf9990be650">executor_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the executor associated with the object. </p>

</div>
</div>
<a id="ab2ba54a920426d82acdddd7094e451fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ba54a920426d82acdddd7094e451fa">&#9670;&nbsp;</a></span>native_handle_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The native representation of an acceptor. </p>

</div>
</div>
<a id="a33ca71bda7efef6da54ad711b7fd2222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca71bda7efef6da54ad711b7fd2222">&#9670;&nbsp;</a></span>protocol_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The protocol type. </p>

</div>
</div>
<a id="a7e07d5a917bd1fa5392fe648759a9746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e07d5a917bd1fa5392fe648759a9746">&#9670;&nbsp;</a></span>endpoint_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Protocol::endpoint <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The endpoint type. </p>

</div>
</div>
<a id="ac3cf77465dfedfe1979b5415cf32cc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3cf77465dfedfe1979b5415cf32cc94">&#9670;&nbsp;</a></span>message_flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="classasio_1_1socket__base.html#ac3cf77465dfedfe1979b5415cf32cc94">asio::socket_base::message_flags</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bitmask type for flags that can be passed to send and receive operations. </p>

</div>
</div>
<a id="aee34d723e630ad0cc0b745ca5f6dc2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee34d723e630ad0cc0b745ca5f6dc2ba">&#9670;&nbsp;</a></span>broadcast</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#aee34d723e630ad0cc0b745ca5f6dc2ba">asio::socket_base::broadcast</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to permit sending of broadcast messages. </p>
<p>Implements the SOL_SOCKET/SO_BROADCAST socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__datagram__socket.html">asio::ip::udp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::broadcast option(<span class="keyword">true</span>);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__datagram__socket.html">asio::ip::udp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::broadcast option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="ad2c3c8844bdf08f6f74fae000d6d7217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c3c8844bdf08f6f74fae000d6d7217">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#ad2c3c8844bdf08f6f74fae000d6d7217">asio::socket_base::debug</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to enable socket-level debugging. </p>
<p>Implements the SOL_SOCKET/SO_DEBUG socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::debug option(<span class="keyword">true</span>);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::debug option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="a4220b1b3fd7ca674d8adedb742d71680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4220b1b3fd7ca674d8adedb742d71680">&#9670;&nbsp;</a></span>do_not_route</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a4220b1b3fd7ca674d8adedb742d71680">asio::socket_base::do_not_route</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to prevent routing, use local interfaces only. </p>
<p>Implements the SOL_SOCKET/SO_DONTROUTE socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__datagram__socket.html">asio::ip::udp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::do_not_route option(<span class="keyword">true</span>);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__datagram__socket.html">asio::ip::udp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::do_not_route option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="a493d09a6a851ec400a30e8f22adb9d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493d09a6a851ec400a30e8f22adb9d74">&#9670;&nbsp;</a></span>keep_alive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a493d09a6a851ec400a30e8f22adb9d74">asio::socket_base::keep_alive</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to send keep-alives. </p>
<p>Implements the SOL_SOCKET/SO_KEEPALIVE socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::keep_alive option(<span class="keyword">true</span>);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::keep_alive option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="a8869a31e4367e9b62c08609dc89591b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8869a31e4367e9b62c08609dc89591b2">&#9670;&nbsp;</a></span>send_buffer_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a8869a31e4367e9b62c08609dc89591b2">asio::socket_base::send_buffer_size</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option for the send buffer size of a socket. </p>
<p>Implements the SOL_SOCKET/SO_SNDBUF socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::send_buffer_size option(8192);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::send_buffer_size option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">int</span> size = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div>
<a id="abff502237f6a2e248e68483e9ca6a0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff502237f6a2e248e68483e9ca6a0d2">&#9670;&nbsp;</a></span>send_low_watermark</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#abff502237f6a2e248e68483e9ca6a0d2">asio::socket_base::send_low_watermark</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option for the send low watermark. </p>
<p>Implements the SOL_SOCKET/SO_SNDLOWAT socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::send_low_watermark option(1024);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::send_low_watermark option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">int</span> size = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div>
<a id="ad79401946636f3e91c1cc66436d1f975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79401946636f3e91c1cc66436d1f975">&#9670;&nbsp;</a></span>receive_buffer_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#ad79401946636f3e91c1cc66436d1f975">asio::socket_base::receive_buffer_size</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option for the receive buffer size of a socket. </p>
<p>Implements the SOL_SOCKET/SO_RCVBUF socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::receive_buffer_size option(8192);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::receive_buffer_size option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">int</span> size = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div>
<a id="af487bc8987ef57e2c7469b40bba591a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af487bc8987ef57e2c7469b40bba591a3">&#9670;&nbsp;</a></span>receive_low_watermark</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#af487bc8987ef57e2c7469b40bba591a3">asio::socket_base::receive_low_watermark</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option for the receive low watermark. </p>
<p>Implements the SOL_SOCKET/SO_RCVLOWAT socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::receive_low_watermark option(1024);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::receive_low_watermark option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">int</span> size = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Integer_Socket_Option. </dd></dl>

</div>
</div>
<a id="a66ab5649a23766107c5da2a04993d8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ab5649a23766107c5da2a04993d8dc">&#9670;&nbsp;</a></span>reuse_address</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc">asio::socket_base::reuse_address</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to allow the socket to be bound to an address that is already in use. </p>
<p>Implements the SOL_SOCKET/SO_REUSEADDR socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::reuse_address option(<span class="keyword">true</span>);</div><div class="line">acceptor.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::reuse_address option;</div><div class="line">acceptor.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="a308e86dd1ee896dd26c07abf7e6ff1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308e86dd1ee896dd26c07abf7e6ff1b5">&#9670;&nbsp;</a></span>linger</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a308e86dd1ee896dd26c07abf7e6ff1b5">asio::socket_base::linger</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to specify whether the socket lingers on close if unsent data is present. </p>
<p>Implements the SOL_SOCKET/SO_LINGER socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::linger option(<span class="keyword">true</span>, 30);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::linger option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.enabled();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> timeout = option.timeout();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Linger_Socket_Option. </dd></dl>

</div>
</div>
<a id="a38622a265bda555107ce6d97bed8d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38622a265bda555107ce6d97bed8d739">&#9670;&nbsp;</a></span>out_of_band_inline</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a38622a265bda555107ce6d97bed8d739">asio::socket_base::out_of_band_inline</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option for putting received out-of-band data inline. </p>
<p>Implements the SOL_SOCKET/SO_OOBINLINE socket option.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context);</div><div class="line">...</div><div class="line">asio::socket_base::out_of_band_inline option(<span class="keyword">true</span>);</div><div class="line">socket.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context);</div><div class="line">...</div><div class="line">asio::socket_base::out_of_band_inline option;</div><div class="line">socket.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> value = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="a9ef00aa2ca23006e9868f2ea46223aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef00aa2ca23006e9868f2ea46223aea">&#9670;&nbsp;</a></span>enable_connection_aborted</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#a9ef00aa2ca23006e9868f2ea46223aea">asio::socket_base::enable_connection_aborted</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Socket option to report aborted connections on accept. </p>
<p>Implements a custom socket option that determines whether or not an accept operation is permitted to fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da58e2f13d5e22e6a6381c7e96883b76e1" title="A connection has been aborted. ">asio::error::connection_aborted</a>. By default the option is false.</p>
<dl class="section user"><dt>Examples</dt><dd>Setting the option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::enable_connection_aborted option(<span class="keyword">true</span>);</div><div class="line">acceptor.set_option(option);</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt></dt><dd>Getting the current option value: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::enable_connection_aborted option;</div><div class="line">acceptor.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.value();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>Socket_Option, Boolean_Socket_Option. </dd></dl>

</div>
</div>
<a id="abbde8e590fbb98dfa1685b9d435cb5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbde8e590fbb98dfa1685b9d435cb5dc">&#9670;&nbsp;</a></span>bytes_readable</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef implementation_defined <a class="el" href="classasio_1_1socket__base.html#abbde8e590fbb98dfa1685b9d435cb5dc">asio::socket_base::bytes_readable</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IO control command to get the amount of data that can be read without blocking. </p>
<p>Implements the FIONREAD IO control command.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(io_context); </div><div class="line">...</div><div class="line">asio::socket_base::bytes_readable command(<span class="keyword">true</span>);</div><div class="line">socket.io_control(command);</div><div class="line">std::size_t bytes_readable = command.get();</div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Concepts:</dt><dd>IO_Control_Command, Size_IO_Control_Command. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a915e52ff147efd296350bba81f795c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915e52ff147efd296350bba81f795c37">&#9670;&nbsp;</a></span>shutdown_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classasio_1_1socket__base.html#a915e52ff147efd296350bba81f795c37">asio::socket_base::shutdown_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different ways a socket may be shutdown. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a915e52ff147efd296350bba81f795c37acbfe078d69142138f3162984ba6a1b9b"></a>shutdown_receive&#160;</td><td class="fielddoc"><p>Shutdown the receive side of the socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="a915e52ff147efd296350bba81f795c37a042d0121d26acaa45a86e0db3cb8aa62"></a>shutdown_send&#160;</td><td class="fielddoc"><p>Shutdown the send side of the socket. </p>
</td></tr>
<tr><td class="fieldname"><a id="a915e52ff147efd296350bba81f795c37a66b86f5f0b2524bc7652dc9c7c82c0fd"></a>shutdown_both&#160;</td><td class="fielddoc"><p>Shutdown both send and receive on the socket. </p>
</td></tr>
</table>

</div>
</div>
<a id="a93ecdd0897737c322ba27c6900205473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ecdd0897737c322ba27c6900205473">&#9670;&nbsp;</a></span>wait_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">asio::socket_base::wait_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait types. </p>
<p>For use with <a class="el" href="classasio_1_1basic__socket.html#a067d72e8a710df58d9dfba9ccaf52a20" title="Wait for the socket to become ready to read, ready to write, or to have pending error conditions...">basic_socket::wait()</a> and <a class="el" href="classasio_1_1basic__socket.html#acce51ffe06bc332536f0b0ba9029a6df" title="Asynchronously wait for the socket to become ready to read, ready to write, or to have pending error ...">basic_socket::async_wait()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a93ecdd0897737c322ba27c6900205473af1fa856779abbb3f088ea697401e8f9b"></a>wait_read&#160;</td><td class="fielddoc"><p>Wait for a socket to become ready to read. </p>
</td></tr>
<tr><td class="fieldname"><a id="a93ecdd0897737c322ba27c6900205473adbaf5ba901a18c5f8bf3ca2f9b995250"></a>wait_write&#160;</td><td class="fielddoc"><p>Wait for a socket to become ready to write. </p>
</td></tr>
<tr><td class="fieldname"><a id="a93ecdd0897737c322ba27c6900205473afcdf41a7959efd856c2fc99f31903486"></a>wait_error&#160;</td><td class="fielddoc"><p>Wait for a socket to have error conditions pending. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a55e23f093c1f957fa0cd77bd30978b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e23f093c1f957fa0cd77bd30978b93">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an acceptor without opening it. </p>
<p>This constructor creates an acceptor without opening it to listen for new connections. The <a class="el" href="classasio_1_1basic__socket__acceptor.html#a26b28c14b1b10df9cd0b82e3d489782a" title="Open the acceptor using the specified protocol. ">open()</a> function must be called before the acceptor can accept new socket connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac112e0d4bde0de5fe5193d52bf477efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac112e0d4bde0de5fe5193d52bf477efa">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an open acceptor. </p>
<p>This constructor creates an acceptor and automatically opens it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae538b2481895eaa9283c651aa5b16e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae538b2481895eaa9283c651aa5b16e6f">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reuse_addr</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an acceptor opened on the given endpoint. </p>
<p>This constructor creates an acceptor and automatically opens it to listen for new connections on the specified endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine on which the acceptor will listen for new connections.</td></tr>
    <tr><td class="paramname">reuse_addr</td><td>Whether the constructor should set the socket option <a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc" title="Socket option to allow the socket to be bound to an address that is already in use. ">socket_base::reuse_address</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This constructor is equivalent to the following code: <div class="fragment"><div class="line">basic_socket_acceptor&lt;Protocol&gt; acceptor(io_context);</div><div class="line">acceptor.open(endpoint.<a class="code" href="classasio_1_1ip_1_1basic__endpoint.html#aa9c4d0afb36a788547d8610722627446">protocol</a>());</div><div class="line"><span class="keywordflow">if</span> (reuse_addr)</div><div class="line">  acceptor.set_option(<a class="code" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc">socket_base::reuse_address</a>(<span class="keyword">true</span>));</div><div class="line">acceptor.bind(endpoint);</div><div class="line">acceptor.listen(listen_backlog);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab00dbd4d350fa20c4291a157a904ed1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00dbd4d350fa20c4291a157a904ed1e">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> on an existing native acceptor. </p>
<p>This constructor creates an acceptor object to hold an existing native acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the acceptor will use to dispatch handlers for any asynchronous operations performed on the acceptor.</td></tr>
    <tr><td class="paramname">protocol</td><td>An object specifying protocol parameters to be used.</td></tr>
    <tr><td class="paramname">native_acceptor</td><td>A native acceptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad0a01f1178d21df1d93f1e6ecabe0167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a01f1178d21df1d93f1e6ecabe0167">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from another. </p>
<p>This constructor moves an acceptor from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1basic__socket__acceptor.html#a55e23f093c1f957fa0cd77bd30978b93" title="Construct an acceptor without opening it. ">basic_socket_acceptor(io_context&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="acde4cf212a1d9cd2012971c55ca3ca2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde4cf212a1d9cd2012971c55ca3ca2c">&#9670;&nbsp;</a></span>basic_socket_acceptor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol1 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; Protocol1, Protocol &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-construct a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from an acceptor of another protocol type. </p>
<p>This constructor moves an acceptor from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code>basic_socket(io_context&amp;)</code> constructor. </dd></dl>

</div>
</div>
<a id="ac5c9b82fcc5bdee7c2a855d13c68a078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5c9b82fcc5bdee7c2a855d13c68a078">&#9670;&nbsp;</a></span>~basic_socket_acceptor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::~<a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the acceptor. </p>
<p>This function destroys the acceptor, cancelling any outstanding asynchronous operations associated with the acceptor as if by calling <code>cancel</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9c1867a3218bc3b4b69987e365f587ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1867a3218bc3b4b69987e365f587ae">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&amp; <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-assign a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from another. </p>
<p>This assignment operator moves an acceptor from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code><a class="el" href="classasio_1_1basic__socket__acceptor.html#a55e23f093c1f957fa0cd77bd30978b93" title="Construct an acceptor without opening it. ">basic_socket_acceptor(io_context&amp;)</a></code> constructor. </dd></dl>

</div>
</div>
<a id="a3e593fce13b015b599ad57590e28d4bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e593fce13b015b599ad57590e28d4bf">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enable_if&lt;is_convertible&lt;Protocol1, Protocol&gt;::value, <a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&gt;::type&amp; <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a>&lt; Protocol1 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-assign a <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> from an acceptor of another protocol type. </p>
<p>This assignment operator moves an acceptor from one object to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classasio_1_1basic__socket__acceptor.html" title="Provides the ability to accept new connections. ">basic_socket_acceptor</a> object from which the move will occur.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Following the move, the moved-from object is in the same state as if constructed using the <code>basic_socket(io_context&amp;)</code> constructor. </dd></dl>

</div>
</div>
<a id="a079765bc41659ceebe0f234bffa3d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079765bc41659ceebe0f234bffa3d1fc">&#9670;&nbsp;</a></span>get_io_context()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a>&amp; <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::get_io_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated: Use <a class="el" href="classasio_1_1basic__socket__acceptor.html#afd3b6aad87e62c6807f468b04528cdcf" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object. </p>
<p>This function may be used to obtain the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a8880ec61ec174c58019375519fc4fb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8880ec61ec174c58019375519fc4fb40">&#9670;&nbsp;</a></span>get_io_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a>&amp; <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated: Use <a class="el" href="classasio_1_1basic__socket__acceptor.html#afd3b6aad87e62c6807f468b04528cdcf" title="Get the executor associated with the object. ">get_executor()</a>.) Get the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> associated with the object. </p>
<p>This function may be used to obtain the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that the I/O object will use to dispatch handlers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="afd3b6aad87e62c6807f468b04528cdcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3b6aad87e62c6807f468b04528cdcf">&#9670;&nbsp;</a></span>get_executor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a990444d2e4091b61e859baf9990be650">executor_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::get_executor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the executor associated with the object. </p>

</div>
</div>
<a id="a26b28c14b1b10df9cd0b82e3d489782a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b28c14b1b10df9cd0b82e3d489782a">&#9670;&nbsp;</a></span>open() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em> = <code><a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the acceptor using the specified protocol. </p>
<p>This function opens the socket acceptor so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">acceptor.open(<a class="code" href="classasio_1_1ip_1_1tcp.html#a5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>());</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a833c3c5271ac8f863d443578a983e751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833c3c5271ac8f863d443578a983e751">&#9670;&nbsp;</a></span>open() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the acceptor using the specified protocol. </p>
<p>This function opens the socket acceptor so that it will use the specified protocol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">protocol</td><td>An object specifying which protocol is to be used.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.open(<a class="code" href="classasio_1_1ip_1_1tcp.html#a5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2d729725e46ee4c959583e30b4fc7ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d729725e46ee4c959583e30b4fc7ba6">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_acceptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns an existing native acceptor to the acceptor. </p>

</div>
</div>
<a id="a9970022c0898229ab455c7a1b6cc22a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9970022c0898229ab455c7a1b6cc22a1">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &amp;&#160;</td>
          <td class="paramname"><em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> &amp;&#160;</td>
          <td class="paramname"><em>native_acceptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns an existing native acceptor to the acceptor. </p>

</div>
</div>
<a id="aa1eb3a8b87f8991e07aa1e307be5d5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eb3a8b87f8991e07aa1e307be5d5be">&#9670;&nbsp;</a></span>is_open()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the acceptor is open. </p>

</div>
</div>
<a id="ae864f92000099822824daaf54ebe0775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae864f92000099822824daaf54ebe0775">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the acceptor to the given local endpoint. </p>
<p>This function binds the socket acceptor to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket acceptor will be bound.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>(<a class="code" href="classasio_1_1ip_1_1tcp.html#a5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345);</div><div class="line">acceptor.open(endpoint.<a class="code" href="classasio_1_1ip_1_1basic__endpoint.html#aa9c4d0afb36a788547d8610722627446">protocol</a>());</div><div class="line">acceptor.bind(endpoint);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aec7a36634808ef33cc76aa389d66913d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7a36634808ef33cc76aa389d66913d">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the acceptor to the given local endpoint. </p>
<p>This function binds the socket acceptor to the specified endpoint on the local machine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>An endpoint on the local machine to which the socket acceptor will be bound.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>(<a class="code" href="classasio_1_1ip_1_1tcp.html#a5123c64b44b4c5fd3c016ce75cbf096d">asio::ip::tcp::v4</a>(), 12345);</div><div class="line">acceptor.open(endpoint.<a class="code" href="classasio_1_1ip_1_1basic__endpoint.html#aa9c4d0afb36a788547d8610722627446">protocol</a>());</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.bind(endpoint, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af23fc2d25ba6a3b24f5207342574c467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23fc2d25ba6a3b24f5207342574c467">&#9670;&nbsp;</a></span>listen() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em> = <code><a class="el" href="classasio_1_1socket__base.html#a52b79fd51640a1a2ee3baed5f897a674">socket_base::max_listen_connections</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place the acceptor into the state where it will listen for new connections. </p>
<p>This function puts the socket acceptor into the state where it may accept new connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>The maximum length of the queue of pending connections.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86fcdb899768b9875dd901785d1358b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fcdb899768b9875dd901785d1358b1">&#9670;&nbsp;</a></span>listen() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Place the acceptor into the state where it will listen for new connections. </p>
<p>This function puts the socket acceptor into the state where it may accept new connections.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backlog</td><td>The maximum length of the queue of pending connections.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::error_code ec;</div><div class="line">acceptor.listen(<a class="code" href="classasio_1_1socket__base.html#a52b79fd51640a1a2ee3baed5f897a674">asio::socket_base::max_listen_connections</a>, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="af15976cd1f2861d9a2c622b9285a04be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15976cd1f2861d9a2c622b9285a04be">&#9670;&nbsp;</a></span>close() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the acceptor. </p>
<p>This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.</p>
<p>A subsequent call to <a class="el" href="classasio_1_1basic__socket__acceptor.html#a26b28c14b1b10df9cd0b82e3d489782a" title="Open the acceptor using the specified protocol. ">open()</a> is required before the acceptor can again be used to again perform socket accept operations.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa654ec70ffe0dc59f755dcfaa59d0e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa654ec70ffe0dc59f755dcfaa59d0e22">&#9670;&nbsp;</a></span>close() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the acceptor. </p>
<p>This function is used to close the acceptor. Any asynchronous accept operations will be cancelled immediately.</p>
<p>A subsequent call to <a class="el" href="classasio_1_1basic__socket__acceptor.html#a26b28c14b1b10df9cd0b82e3d489782a" title="Open the acceptor using the specified protocol. ">open()</a> is required before the acceptor can again be used to again perform socket accept operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::error_code ec;</div><div class="line">acceptor.close(ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="add9b422aa5cf1782e8a1df888fe5e8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9b422aa5cf1782e8a1df888fe5e8ef">&#9670;&nbsp;</a></span>release() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of the underlying native acceptor. </p>
<p>This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error. Ownership of the native acceptor is then transferred to the caller.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90daf5c69ee1029871764a105a18648aec91" title="Operation not supported. ">asio::error::operation_not_supported</a> on these platforms. </dd></dl>

</div>
</div>
<a id="aa4b7f16c397b76f2fdd05b757539622c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b7f16c397b76f2fdd05b757539622c">&#9670;&nbsp;</a></span>release() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release ownership of the underlying native acceptor. </p>
<p>This function causes all outstanding asynchronous accept operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error. Ownership of the native acceptor is then transferred to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is unsupported on Windows versions prior to Windows 8.1, and will fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90daf5c69ee1029871764a105a18648aec91" title="Operation not supported. ">asio::error::operation_not_supported</a> on these platforms. </dd></dl>

</div>
</div>
<a id="afa627d7f63e07c125b7b12c679b5b3a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa627d7f63e07c125b7b12c679b5b3a1">&#9670;&nbsp;</a></span>native_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#ab2ba54a920426d82acdddd7094e451fa">native_handle_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::native_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the native acceptor representation. </p>
<p>This function may be used to obtain the underlying representation of the acceptor. This is intended to allow access to native acceptor functionality that is not otherwise provided. </p>

</div>
</div>
<a id="a49e99268148000d633db4f9d9ab5c9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e99268148000d633db4f9d9ab5c9ff">&#9670;&nbsp;</a></span>cancel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the acceptor. </p>
<p>This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7834c3851f3264ef4f5dbaba78d8135b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7834c3851f3264ef4f5dbaba78d8135b">&#9670;&nbsp;</a></span>cancel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel all asynchronous operations associated with the acceptor. </p>
<p>This function causes all outstanding asynchronous connect, send and receive operations to finish immediately, and the handlers for cancelled operations will be passed the <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90dacde6760763051561f6c2ffc4ddf2be1b" title="Operation cancelled. ">asio::error::operation_aborted</a> error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd972c85115ae7835197a2083bbf3395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd972c85115ae7835197a2083bbf3395">&#9670;&nbsp;</a></span>set_option() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option on the acceptor. </p>
<p>This function is used to set an option on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the acceptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br />
<a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc" title="Socket option to allow the socket to be bound to an address that is already in use. ">asio::socket_base::reuse_address</a> <a class="el" href="classasio_1_1socket__base.html#a9ef00aa2ca23006e9868f2ea46223aea" title="Socket option to report aborted connections on accept. ">asio::socket_base::enable_connection_aborted</a></dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::reuse_address option(<span class="keyword">true</span>);</div><div class="line">acceptor.set_option(option);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ad32068c807816c25a4dc571f94330588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32068c807816c25a4dc571f94330588">&#9670;&nbsp;</a></span>set_option() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename SettableSocketOption &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype">const SettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an option on the acceptor. </p>
<p>This function is used to set an option on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The new option value to be set on the acceptor.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>SettableSocketOption <br />
<a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc" title="Socket option to allow the socket to be bound to an address that is already in use. ">asio::socket_base::reuse_address</a> <a class="el" href="classasio_1_1socket__base.html#a9ef00aa2ca23006e9868f2ea46223aea" title="Socket option to report aborted connections on accept. ">asio::socket_base::enable_connection_aborted</a></dd></dl>
<dl class="section user"><dt>Example</dt><dd>Setting the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::reuse_address option(<span class="keyword">true</span>);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.set_option(option, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a43ab106c15bb49801b6322a27564a861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ab106c15bb49801b6322a27564a861">&#9670;&nbsp;</a></span>get_option() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an option from the acceptor. </p>
<p>This function is used to get the current value of an option on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the acceptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br />
<a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc" title="Socket option to allow the socket to be bound to an address that is already in use. ">asio::socket_base::reuse_address</a></dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::reuse_address option;</div><div class="line">acceptor.get_option(option);</div><div class="line"><span class="keywordtype">bool</span> is_set = option.get();</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a78b96dffa39e583e0fd34c23f8086bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b96dffa39e583e0fd34c23f8086bc3">&#9670;&nbsp;</a></span>get_option() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename GettableSocketOption &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">GettableSocketOption &amp;&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an option from the acceptor. </p>
<p>This function is used to get the current value of an option on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>The option value to be obtained from the acceptor.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>GettableSocketOption <br />
<a class="el" href="classasio_1_1socket__base.html#a66ab5649a23766107c5da2a04993d8dc" title="Socket option to allow the socket to be bound to an address that is already in use. ">asio::socket_base::reuse_address</a></dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the value of the SOL_SOCKET/SO_REUSEADDR option: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::reuse_address option;</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.get_option(option, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div><div class="line"><span class="keywordtype">bool</span> is_set = option.get();</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9d2df51acdf2d3b13237b6a607384d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2df51acdf2d3b13237b6a607384d2e">&#9670;&nbsp;</a></span>io_control() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an IO control command on the acceptor. </p>
<p>This function is used to execute an IO control command on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the acceptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br />
asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::non_blocking_io command(<span class="keyword">true</span>);</div><div class="line">socket.io_control(command);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4d44624abcfe22046b2176663ca19905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d44624abcfe22046b2176663ca19905">&#9670;&nbsp;</a></span>io_control() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename IoControlCommand &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::io_control </td>
          <td>(</td>
          <td class="paramtype">IoControlCommand &amp;&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform an IO control command on the acceptor. </p>
<p>This function is used to execute an IO control command on the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The IO control command to be performed on the acceptor.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>IoControlCommand <br />
asio::socket_base::non_blocking_io</dd></dl>
<dl class="section user"><dt>Example</dt><dd>Getting the number of bytes ready to read: <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::acceptor::non_blocking_io command(<span class="keyword">true</span>);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">socket.io_control(command, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae7c0466b8b4173e732c9a90f14ce0f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c0466b8b4173e732c9a90f14ce0f0e">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the acceptor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the acceptor's synchronous operations will fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a>. </dd></dl>

</div>
</div>
<a id="a566c33543bf3ef9ffe19764e97563e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566c33543bf3ef9ffe19764e97563e66">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the acceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the acceptor's synchronous operations will fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a>. </dd></dl>

</div>
</div>
<a id="a2593d091fe5623d93d8dc49b0a9bd1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2593d091fe5623d93d8dc49b0a9bd1db">&#9670;&nbsp;</a></span>non_blocking() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the acceptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the acceptor's synchronous operations will fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> if they are unable to perform the requested operation immediately. If <code>false</code>, synchronous operations will block until complete.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking mode has no effect on the behaviour of asynchronous operations. Asynchronous operations will never fail with the error <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a>. </dd></dl>

</div>
</div>
<a id="a9051a34a5b4620378865f74c0be293c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9051a34a5b4620378865f74c0be293c8">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the non-blocking mode of the native acceptor implementation. </p>
<p>This function is used to retrieve the non-blocking mode of the underlying native acceptor. This mode has no effect on the behaviour of the acceptor object's synchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the underlying acceptor is in non-blocking mode and direct system calls may fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> (or the equivalent system error).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The current non-blocking mode is cached by the acceptor object. Consequently, the return value may be incorrect if the non-blocking mode was set directly on the native acceptor. </dd></dl>

</div>
</div>
<a id="a1f25aca0ed3dacc5dd6e760d442e99cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f25aca0ed3dacc5dd6e760d442e99cd">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native acceptor implementation. </p>
<p>This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying acceptor is put into non-blocking mode and direct system calls may fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> (or the equivalent system error).</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae7c0466b8b4173e732c9a90f14ce0f0e" title="Gets the non-blocking mode of the acceptor. ">non_blocking()</a></code> is <code>true</code>, this function fails with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da30cedfce8621ca9c21dddce0ac27cd09" title="Invalid argument. ">asio::error::invalid_argument</a>, as the combination does not make sense. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a797d78c62bd7778dd7f33a3af1d5ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a797d78c62bd7778dd7f33a3af1d5ae">&#9670;&nbsp;</a></span>native_non_blocking() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::native_non_blocking </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the non-blocking mode of the native acceptor implementation. </p>
<p>This function is used to modify the non-blocking mode of the underlying native acceptor. It has no effect on the behaviour of the acceptor object's synchronous operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>If <code>true</code>, the underlying acceptor is put into non-blocking mode and direct system calls may fail with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da8e8ff1984495eb85ec17c37e3e5a89e5" title="The socket is marked non-blocking and the requested operation would block. ">asio::error::would_block</a> (or the equivalent system error).</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. If the <code>mode</code> is <code>false</code>, but the current value of <code><a class="el" href="classasio_1_1basic__socket__acceptor.html#ae7c0466b8b4173e732c9a90f14ce0f0e" title="Gets the non-blocking mode of the acceptor. ">non_blocking()</a></code> is <code>true</code>, this function fails with <a class="el" href="namespaceasio_1_1error.html#a2a69445eee784059ac2f4a6c4f5fe90da30cedfce8621ca9c21dddce0ac27cd09" title="Invalid argument. ">asio::error::invalid_argument</a>, as the combination does not make sense. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9852bcfd2882c59be8c21dffccfd77da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9852bcfd2882c59be8c21dffccfd77da">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local endpoint of the acceptor. </p>
<p>This function is used to obtain the locally bound endpoint of the acceptor.</p>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the acceptor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint endpoint = acceptor.local_endpoint();</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a51562b7296a6cbcaa446b514b8c54019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51562b7296a6cbcaa446b514b8c54019">&#9670;&nbsp;</a></span>local_endpoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::local_endpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the local endpoint of the acceptor. </p>
<p>This function is used to obtain the locally bound endpoint of the acceptor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents the local endpoint of the acceptor. Returns a default-constructed endpoint object if an error occurred and the error handler did not throw an exception.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::error_code ec;</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> endpoint = acceptor.local_endpoint(ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa76a707af7e819077c155780a7c962a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76a707af7e819077c155780a7c962a0">&#9670;&nbsp;</a></span>wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a>&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. </p>
<p>This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired acceptor state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for an acceptor to become readable. <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">acceptor.wait(<a class="code" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473af1fa856779abbb3f088ea697401e8f9b">asio::ip::tcp::acceptor::wait_read</a>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9ae15a6c5b9001970c31b70d7bfac9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae15a6c5b9001970c31b70d7bfac9be">&#9670;&nbsp;</a></span>wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. </p>
<p>This function is used to perform a blocking wait for an acceptor to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired acceptor state.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Waiting for an acceptor to become readable. <div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::error_code ec;</div><div class="line">acceptor.wait(<a class="code" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473af1fa856779abbb3f088ea697401e8f9b">asio::ip::tcp::acceptor::wait_read</a>, ec);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a40abf261e0fa367b2c37fa0fc54c3374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40abf261e0fa367b2c37fa0fc54c3374">&#9670;&nbsp;</a></span>async_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename WaitHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473">wait_type</a>&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WaitHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously wait for the acceptor to become ready to read, ready to write, or to have pending error conditions. </p>
<p>This function is used to perform an asynchronous wait for an acceptor to enter a ready to read, write or error condition state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>Specifies the desired acceptor state.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the wait operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> wait_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Wait succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">acceptor.async_wait(</div><div class="line">    <a class="code" href="classasio_1_1socket__base.html#a93ecdd0897737c322ba27c6900205473af1fa856779abbb3f088ea697401e8f9b">asio::ip::tcp::acceptor::wait_read</a>,</div><div class="line">    wait_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a173775e7f30cd7f1f781cb052c8dbf00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173775e7f30cd7f1f781cb052c8dbf00">&#9670;&nbsp;</a></span>accept() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(io_context);</div><div class="line">acceptor.accept(socket);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ae9b188e244f79a7949a6b1e91987eb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b188e244f79a7949a6b1e91987eb19">&#9670;&nbsp;</a></span>accept() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer into the given socket. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(io_context);</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.accept(socket, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a225dfadc107aa7d7f8ff1d5cbf43d377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225dfadc107aa7d7f8ff1d5cbf43d377">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 , typename AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; Protocol, Protocol1 &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection into a socket. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Accept succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(io_context);</div><div class="line">acceptor.async_accept(socket, accept_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a899f093d3e4eec39c47ce8f7397b1611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899f093d3e4eec39c47ce8f7397b1611">&#9670;&nbsp;</a></span>accept() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection and obtain the endpoint of the peer. </p>
<p>This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object which will receive the endpoint of the remote peer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(io_context);</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line">acceptor.accept(socket, endpoint);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aa704547d75b5336438f62ee5bf4e1d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa704547d75b5336438f62ee5bf4e1d9f">&#9670;&nbsp;</a></span>accept() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection and obtain the endpoint of the peer. </p>
<p>This function is used to accept a new connection from a peer into the given socket, and additionally provide the endpoint of the remote peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object which will receive the endpoint of the remote peer.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(io_context);</div><div class="line"><a class="code" href="classasio_1_1ip_1_1basic__endpoint.html">asio::ip::tcp::endpoint</a> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line"><a class="code" href="classasio_1_1error__code.html">asio::error_code</a> ec;</div><div class="line">acceptor.accept(socket, endpoint, ec);</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aeb4557677655d9a7cd1db84409fb807e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4557677655d9a7cd1db84409fb807e">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; <a class="el" href="classasio_1_1basic__socket__acceptor.html#a33ca71bda7efef6da54ad711b7fd2222">protocol_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection into a socket, and additionally obtain the endpoint of the remote peer. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer</td><td>The socket into which the new connection will be accepted. Ownership of the peer object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error <span class="comment">// Result of operation.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4e7ddfbe5c0a00e4e490e9549e8c2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e7ddfbe5c0a00e4e490e9549e8c2bf">&#9670;&nbsp;</a></span>accept() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="section return"><dt>Returns</dt><dd>A socket object representing the newly accepted connection.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(acceptor.accept());</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a279d30b9a66c9a758d3ce029431463a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279d30b9a66c9a758d3ce029431463a4">&#9670;&nbsp;</a></span>accept() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket object representing the newly accepted connection. On error, a socket object where <a class="el" href="classasio_1_1basic__socket__acceptor.html#aa1eb3a8b87f8991e07aa1e307be5d5be" title="Determine whether the acceptor is open. ">is_open()</a> is false.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(acceptor.accept(ec));</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a4a6e36dfed58f611a767c3898c5f32fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6e36dfed58f611a767c3898c5f32fa">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename MoveAcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype">MoveAcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection. The function call always returns immediately.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">typename</span> Protocol::socket peer <span class="comment">// On success, the newly accepted socket.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div><div class="line">    <a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> peer)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Accept succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">acceptor.async_accept(accept_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a5db636445be89426c61abfe8bf734462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db636445be89426c61abfe8bf734462">&#9670;&nbsp;</a></span>accept() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A socket object representing the newly accepted connection.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(acceptor.accept());</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac3d11d23f0909e3d6f795f54b0ceaac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d11d23f0909e3d6f795f54b0ceaac3">&#9670;&nbsp;</a></span>accept() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket object representing the newly accepted connection. On error, a socket object where <a class="el" href="classasio_1_1basic__socket__acceptor.html#aa1eb3a8b87f8991e07aa1e307be5d5be" title="Determine whether the acceptor is open. ">is_open()</a> is false.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::socket socket(acceptor.accept(io_context2, ec));</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a433977dfe2781e74d5990369515d8676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433977dfe2781e74d5990369515d8676">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename MoveAcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MoveAcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection. The function call always returns immediately.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">typename</span> Protocol::socket peer <span class="comment">// On success, the newly accepted socket.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div><div class="line">    <a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> peer)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Accept succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">acceptor.async_accept(io_context2, accept_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a2b376b38018d85c0fdb92067cc91b797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b376b38018d85c0fdb92067cc91b797">&#9670;&nbsp;</a></span>accept() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A socket object representing the newly accepted connection.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(acceptor.accept(endpoint));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1bb6870e2e1683985d59d5f17feb509e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb6870e2e1683985d59d5f17feb509e">&#9670;&nbsp;</a></span>accept() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket object representing the newly accepted connection. On error, a socket object where <a class="el" href="classasio_1_1basic__socket__acceptor.html#aa1eb3a8b87f8991e07aa1e307be5d5be" title="Determine whether the acceptor is open. ">is_open()</a> is false.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(acceptor.accept(endpoint, ec));</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a62733167c135f18d91181b6b84f4f415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62733167c135f18d91181b6b84f4f415">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename MoveAcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MoveAcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection. The function call always returns immediately.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">typename</span> Protocol::socket peer <span class="comment">// On success, the newly accepted socket.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div><div class="line">    <a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> peer)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Accept succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line">acceptor.async_accept(endpoint, accept_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ab1bef5bbc23f91deb6468976044a5af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1bef5bbc23f91deb6468976044a5af2">&#9670;&nbsp;</a></span>accept() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A socket object representing the newly accepted connection.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(</div><div class="line">    acceptor.accept(io_context2, endpoint));</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a9753590b4d69d74853864884460a0240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9753590b4d69d74853864884460a0240">&#9670;&nbsp;</a></span>accept() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::socket <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accept a new connection. </p>
<p>This function is used to accept a new connection from a peer. The function call will block until a new connection has been accepted successfully or an error occurs.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a socket object representing the newly accepted connection. On error, a socket object where <a class="el" href="classasio_1_1basic__socket__acceptor.html#aa1eb3a8b87f8991e07aa1e307be5d5be" title="Determine whether the acceptor is open. ">is_open()</a> is false.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><a class="code" href="classasio_1_1basic__socket__acceptor.html">asio::ip::tcp::acceptor</a> acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line"><a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> socket(</div><div class="line">    acceptor.accept(io_context2, endpoint, ec));</div><div class="line"><span class="keywordflow">if</span> (ec)</div><div class="line">{</div><div class="line">  <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="add007866bac2a91fd8b9e31d5143b2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add007866bac2a91fd8b9e31d5143b2dc">&#9670;&nbsp;</a></span>async_accept() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename MoveAcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced <a class="el" href="classasio_1_1basic__socket__acceptor.html">asio::basic_socket_acceptor</a>&lt; Protocol &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">asio::io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>io_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket__acceptor.html#a7e07d5a917bd1fa5392fe648759a9746">endpoint_type</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MoveAcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous accept. </p>
<p>This function is used to asynchronously accept a new connection. The function call always returns immediately.</p>
<p>This overload requires that the Protocol template parameter satisfy the AcceptableProtocol type requirements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a></td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object to be used for the newly accepted socket.</td></tr>
    <tr><td class="paramname">peer_endpoint</td><td>An endpoint object into which the endpoint of the remote peer will be written. Ownership of the peer_endpoint object is retained by the caller, which must guarantee that it is valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the accept operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error, <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">typename</span> Protocol::socket peer <span class="comment">// On success, the newly accepted socket.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keywordtype">void</span> accept_handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; error,</div><div class="line">    <a class="code" href="classasio_1_1basic__stream__socket.html">asio::ip::tcp::socket</a> peer)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!error)</div><div class="line">  {</div><div class="line">    <span class="comment">// Accept succeeded.</span></div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">asio::ip::tcp::acceptor acceptor(io_context);</div><div class="line">...</div><div class="line">asio::ip::tcp::endpoint <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>;</div><div class="line">acceptor.async_accept(io_context2, endpoint, accept_handler);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae6f984a5196e3773bb097fcd759982da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f984a5196e3773bb097fcd759982da">&#9670;&nbsp;</a></span>basic_socket_acceptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol &gt; </div>
<div class="memtemplate">
template&lt;typename Protocol1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a356e1bd7da0353e5472028cdec742ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356e1bd7da0353e5472028cdec742ed0">&#9670;&nbsp;</a></span>message_peek</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::message_peek = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Peek at incoming data without removing it from the input queue. </p>

</div>
</div>
<a id="ab9f08ba445b7ce09ece5ac7beaa6e7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f08ba445b7ce09ece5ac7beaa6e7c9">&#9670;&nbsp;</a></span>message_out_of_band</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::message_out_of_band = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process out-of-band data. </p>

</div>
</div>
<a id="ae27428a48d1a7113a95ea205b1e17978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27428a48d1a7113a95ea205b1e17978">&#9670;&nbsp;</a></span>message_do_not_route</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::message_do_not_route = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify that the data should not be subject to routing. </p>

</div>
</div>
<a id="ade1439c2255d52f1ec68da5fa3f40ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1439c2255d52f1ec68da5fa3f40ee1">&#9670;&nbsp;</a></span>message_end_of_record</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::message_end_of_record = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that the data marks the end of a record. </p>

</div>
</div>
<a id="a52b79fd51640a1a2ee3baed5f897a674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b79fd51640a1a2ee3baed5f897a674">&#9670;&nbsp;</a></span>max_listen_connections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::max_listen_connections = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum length of the queue of pending incoming connections. </p>

</div>
</div>
<a id="a85ee2a3ce0ec68ac8c026884c5bd3098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ee2a3ce0ec68ac8c026884c5bd3098">&#9670;&nbsp;</a></span>max_connections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int asio::socket_base::max_connections = implementation_defined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Deprecated: Use max_listen_connections.) The maximum length of the queue of pending incoming connections. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
