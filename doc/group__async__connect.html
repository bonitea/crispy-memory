<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::async_connect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::async_connect</div>  </div>
</div><!--header-->
<div class="contents">

<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename RangeConnectHandler &gt; </td></tr>
<tr class="memitem:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, RangeConnectHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">More...</a><br /></td></tr>
<tr class="separator:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga71fc5bf86c82a1c7cbe7add1926894c0">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, IteratorConnectHandler &amp;&amp;handler, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga71fc5bf86c82a1c7cbe7add1926894c0">More...</a><br /></td></tr>
<tr class="separator:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#gadc625bd7fc3f0f11b5dde75767c667a3">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, IteratorConnectHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#gadc625bd7fc3f0f11b5dde75767c667a3">More...</a><br /></td></tr>
<tr class="separator:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition , typename RangeConnectHandler &gt; </td></tr>
<tr class="memitem:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#gad4f64fdcdce3e6edf07f6aa796162686">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, RangeConnectHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gad4f64fdcdce3e6edf07f6aa796162686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#gad4f64fdcdce3e6edf07f6aa796162686">More...</a><br /></td></tr>
<tr class="separator:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b55f6360c5c18a93592a428b6e18262"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga7b55f6360c5c18a93592a428b6e18262"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga7b55f6360c5c18a93592a428b6e18262">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, IteratorConnectHandler &amp;&amp;handler, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7b55f6360c5c18a93592a428b6e18262"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga7b55f6360c5c18a93592a428b6e18262">More...</a><br /></td></tr>
<tr class="separator:ga7b55f6360c5c18a93592a428b6e18262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9adfc01630822620058ae54cc4fada1f"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga9adfc01630822620058ae54cc4fada1f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga9adfc01630822620058ae54cc4fada1f">asio::async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition, IteratorConnectHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga9adfc01630822620058ae54cc4fada1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga9adfc01630822620058ae54cc4fada1f">More...</a><br /></td></tr>
<tr class="separator:ga9adfc01630822620058ae54cc4fada1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga982aa1d8db83ed0559ec1d6e52fe6eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga982aa1d8db83ed0559ec1d6e52fe6eb1">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence , typename RangeConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, the successfully connected endpoint.</span></div><div class="line">  <span class="comment">// Otherwise, a default-constructed endpoint.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">r.async_resolve(q, resolve_handler);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> resolve_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    tcp::resolver::results_type <a class="code" href="namespaceasio_1_1placeholders.html#a5f9761808274dc37d15f4ef0c6e03ad9">results</a>)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!ec)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">asio::async_connect</a>(s, results, connect_handler);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> connect_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">tcp::endpoint</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>)</div><div class="line">{</div><div class="line">  <span class="comment">// ...</span></div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga71fc5bf86c82a1c7cbe7add1926894c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71fc5bf86c82a1c7cbe7add1926894c0">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div><div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div><div class="line">  Iterator <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="gadc625bd7fc3f0f11b5dde75767c667a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc625bd7fc3f0f11b5dde75767c667a3">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div><div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div><div class="line">  Iterator <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"> std::vector&lt;tcp::endpoint&gt; endpoints = ...;</div><div class="line">tcp::socket s(io_context);</div><div class="line"><a class="code" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">asio::async_connect</a>(s,</div><div class="line">    endpoints.begin(), endpoints.end(),</div><div class="line">    connect_handler);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> connect_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">std::vector&lt;tcp::endpoint&gt;::iterator</a> i)</div><div class="line">{</div><div class="line">  <span class="comment">// ...</span></div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gad4f64fdcdce3e6edf07f6aa796162686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f64fdcdce3e6edf07f6aa796162686">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition , typename RangeConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EndpointSequence &amp;&#160;</td>
          <td class="paramname"><em>endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RangeConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">endpoints</td><td>A sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div><div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div><div class="line">  Iterator <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">r.async_resolve(q, resolve_handler);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> resolve_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    tcp::resolver::results_type results)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!ec)</div><div class="line">  {</div><div class="line">    <a class="code" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">asio::async_connect</a>(s, results,</div><div class="line">        my_connect_condition(),</div><div class="line">        connect_handler);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> connect_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">tcp::endpoint</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">endpoint</a>)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (ec)</div><div class="line">  {</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; endpoint &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga7b55f6360c5c18a93592a428b6e18262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b55f6360c5c18a93592a428b6e18262">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div><div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div><div class="line">  Iterator <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload assumes that a default constructed object of type <code>Iterator</code> represents the end of the sequence. This is a valid assumption for iterator types such as <code><a class="el" href="classasio_1_1ip_1_1basic__resolver.html#aea89da04bdd7897ca4daacfb7c237b73" title="(Deprecated.) The iterator type. ">asio::ip::tcp::resolver::iterator</a></code>. </dd></dl>

</div>
</div>
<a id="ga9adfc01630822620058ae54cc4fada1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9adfc01630822620058ae54cc4fada1f">&#9670;&nbsp;</a></span>async_connect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConnectCondition&#160;</td>
          <td class="paramname"><em>connect_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorConnectHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously establishes a socket connection by trying each endpoint in a sequence. </p>
<p>This function attempts to connect a socket to one of a sequence of endpoints. It does this by repeated calls to the socket's <code>async_connect</code> member function, once for each endpoint in the sequence, until a connection is successfully established.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The socket to be connected. If the socket is already open, it will be closed.</td></tr>
    <tr><td class="paramname">begin</td><td>An iterator pointing to the start of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">end</td><td>An iterator pointing to the end of a sequence of endpoints.</td></tr>
    <tr><td class="paramname">connect_condition</td><td>A function object that is called prior to each connection attempt. The signature of the function object must be: <div class="fragment"><div class="line"><span class="keywordtype">bool</span> connect_condition(</div><div class="line">   <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">   <span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">Protocol::endpoint</a>&amp; next); </div></div><!-- fragment --> The <code>ec</code> parameter contains the result from the most recent connect operation. Before the first connection attempt, <code>ec</code> is always set to indicate success. The <code>next</code> parameter is the next endpoint to be tried. The function object should return true if the next endpoint should be tried, and false if it should be skipped.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the connect operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation. if the sequence is empty, set to</span></div><div class="line">  <span class="comment">// asio::error::not_found. Otherwise, contains the</span></div><div class="line">  <span class="comment">// error from the last connection attempt.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// On success, an iterator denoting the successfully</span></div><div class="line">  <span class="comment">// connected endpoint. Otherwise, the end iterator.</span></div><div class="line">  Iterator <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>The following connect condition function object can be used to output information about the individual connection attempts: <div class="fragment"><div class="line"> <span class="keyword">struct </span>my_connect_condition</div><div class="line">{</div><div class="line">  <span class="keywordtype">bool</span> operator()(</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">      <a class="code" href="namespaceasio_1_1placeholders.html#a7ee2c0dca31d54ecc78f6f7bec98e15f">const::tcp::endpoint</a>&amp; next)</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span> (ec) std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; ec.<a class="code" href="classasio_1_1error__code.html#a7029a8f8f51f7e03da42bd50c2b3c85b">message</a>() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Trying: &quot;</span> &lt;&lt; next &lt;&lt; std::endl;</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">  }</div><div class="line">}; </div></div><!-- fragment --> It would be used with the <a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b" title="Establishes a socket connection by trying each endpoint in a sequence. ">asio::connect</a> function as follows: <div class="fragment"><div class="line"> tcp::resolver r(io_context);</div><div class="line">tcp::resolver::query q(<span class="stringliteral">&quot;host&quot;</span>, <span class="stringliteral">&quot;service&quot;</span>);</div><div class="line">tcp::socket s(io_context);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line">r.async_resolve(q, resolve_handler);</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> resolve_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">tcp::resolver::iterator</a> i)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!ec)</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">tcp::resolver::iterator</a> end;</div><div class="line">    <a class="code" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">asio::async_connect</a>(s, i, end,</div><div class="line">        my_connect_condition(),</div><div class="line">        connect_handler);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> connect_handler(</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; ec,</div><div class="line">    <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">tcp::resolver::iterator</a> i)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (ec)</div><div class="line">  {</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">  }</div><div class="line">  <span class="keywordflow">else</span></div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Connected to: &quot;</span> &lt;&lt; i-&gt;endpoint() &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">} </div></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
