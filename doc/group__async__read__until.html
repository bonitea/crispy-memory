<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::async_read_until</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::async_read_until</div>  </div>
</div><!--header-->
<div class="contents">

<p>Start an asynchronous operation to read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">asio::async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga95613ed673d2d690b31e6a88ff5f465f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">More...</a><br /></td></tr>
<tr class="separator:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019e323629d84d91ce485bf1051bc50e"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga019e323629d84d91ce485bf1051bc50e"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga019e323629d84d91ce485bf1051bc50e">asio::async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga019e323629d84d91ce485bf1051bc50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__async__read__until.html#ga019e323629d84d91ce485bf1051bc50e">More...</a><br /></td></tr>
<tr class="separator:ga019e323629d84d91ce485bf1051bc50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#gaa9a35d05887ae2041fc0ea4a6115c422">asio::async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression.  <a href="group__async__read__until.html#gaa9a35d05887ae2041fc0ea4a6115c422">More...</a><br /></td></tr>
<tr class="separator:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10641c57596debd0b85e9103e9d81f5a"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename MatchCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga10641c57596debd0b85e9103e9d81f5a"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga10641c57596debd0b85e9103e9d81f5a">asio::async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga10641c57596debd0b85e9103e9d81f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__async__read__until.html#ga10641c57596debd0b85e9103e9d81f5a">More...</a><br /></td></tr>
<tr class="separator:ga10641c57596debd0b85e9103e9d81f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga449c962f7e1a72fbc7c31238b2430ce8">asio::async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter.  <a href="group__async__read__until.html#ga449c962f7e1a72fbc7c31238b2430ce8">More...</a><br /></td></tr>
<tr class="separator:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga2f1d0ed14ba2a45627ec587c20514f59">asio::async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter.  <a href="group__async__read__until.html#ga2f1d0ed14ba2a45627ec587c20514f59">More...</a><br /></td></tr>
<tr class="separator:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f206109b7cf76ff7b5317d9795d315"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gac5f206109b7cf76ff7b5317d9795d315"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#gac5f206109b7cf76ff7b5317d9795d315">asio::async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gac5f206109b7cf76ff7b5317d9795d315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression.  <a href="group__async__read__until.html#gac5f206109b7cf76ff7b5317d9795d315">More...</a><br /></td></tr>
<tr class="separator:gac5f206109b7cf76ff7b5317d9795d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga9766f7ede0a9fe54b96d21fe4a95f754">asio::async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a function object indicates a match.  <a href="group__async__read__until.html#ga9766f7ede0a9fe54b96d21fe4a95f754">More...</a><br /></td></tr>
<tr class="separator:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Start an asynchronous operation to read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga95613ed673d2d690b31e6a88ff5f465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95613ed673d2d690b31e6a88ff5f465f">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div><div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::string line = data.substr(0, n);</div><div class="line">    data.erase(0, n);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, data, <span class="charliteral">&#39;\n&#39;</span>, handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga019e323629d84d91ce485bf1051bc50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga019e323629d84d91ce485bf1051bc50e">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div><div class="line">  <span class="comment">// get area up to and including the delimiter.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::string line = data.substr(0, n);</div><div class="line">    data.erase(0, n);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, data, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="gaa9a35d05887ae2041fc0ea4a6115c422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9a35d05887ae2041fc0ea4a6115c422">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression. </p>
<p>This function is used to asynchronously read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>A substring of the dynamic buffer sequence's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the dynamic buffer sequence's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the dynamic buffer</span></div><div class="line">  <span class="comment">// sequence&#39;s get area up to and including the</span></div><div class="line">  <span class="comment">// substring that matches the regular expression.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::string line = data.substr(0, n);</div><div class="line">    data.erase(0, n);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, data,</div><div class="line">    boost::regex(<span class="stringliteral">&quot;\r\n&quot;</span>), handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the string <code>data</code> contains the data which matched the regular expression: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the match, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the string <code>data</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga10641c57596debd0b85e9103e9d81f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10641c57596debd0b85e9103e9d81f5a">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename MatchCondition , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match. </p>
<p>This function is used to asynchronously read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the dynamic buffer sequence&#39;s</span></div><div class="line">  <span class="comment">// get area that have been fully consumed by the match</span></div><div class="line">  <span class="comment">// function. O if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a <code>std::string</code> until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div><div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a>;</div><div class="line"></div><div class="line">std::pair&lt;iterator, bool&gt;</div><div class="line">match_whitespace(iterator begin, iterator end)</div><div class="line">{</div><div class="line">  iterator i = begin;</div><div class="line">  <span class="keywordflow">while</span> (i != end)</div><div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div><div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div><div class="line">...</div><div class="line">std::string data;</div><div class="line"><a class="code" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">asio::async_read_until</a>(s, data, match_whitespace, handler);</div></div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div><div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div><div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Iterator i = begin;</div><div class="line">    <span class="keywordflow">while</span> (i != end)</div><div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div><div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">char</span> c_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div><div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div><div class="line">    : <span class="keyword">public</span> boost::true_type {};</div><div class="line">} <span class="comment">// namespace asio</span></div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div><div class="line">...</div><div class="line">std::string data;</div><div class="line"><a class="code" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">asio::async_read_until</a>(s, data, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga449c962f7e1a72fbc7c31238b2430ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449c962f7e1a72fbc7c31238b2430ce8">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div><div class="line">  <span class="comment">// area up to and including the delimiter.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::istream is(&amp;b);</div><div class="line">    std::string line;</div><div class="line">    std::getline(is, line);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, b, <span class="charliteral">&#39;\n&#39;</span>, handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga2f1d0ed14ba2a45627ec587c20514f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f1d0ed14ba2a45627ec587c20514f59">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains the delimiter, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div><div class="line">  <span class="comment">// area up to and including the delimiter.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::istream is(&amp;b);</div><div class="line">    std::string line;</div><div class="line">    std::getline(is, line);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, b, <span class="stringliteral">&quot;\r\n&quot;</span>, handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="gac5f206109b7cf76ff7b5317d9795d315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5f206109b7cf76ff7b5317d9795d315">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression. </p>
<p>This function is used to asynchronously read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the streambuf's get area already contains data that matches the regular expression, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div><div class="line">  <span class="comment">// area up to and including the substring</span></div><div class="line">  <span class="comment">// that matches the regular. expression.</span></div><div class="line">  <span class="comment">// 0 if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To asynchronously read data into a streambuf until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size)</div><div class="line">{</div><div class="line">  <span class="keywordflow">if</span> (!e)</div><div class="line">  {</div><div class="line">    std::istream is(&amp;b);</div><div class="line">    std::string line;</div><div class="line">    std::getline(is, line);</div><div class="line">    ...</div><div class="line">  }</div><div class="line">}</div><div class="line">...</div><div class="line">asio::async_read_until(s, b, boost::regex(<span class="stringliteral">&quot;\r\n&quot;</span>), handler); </div></div><!-- fragment --> After the <code>async_read_until</code> operation completes successfully, the buffer <code>b</code> contains the data which matched the regular expression: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the match, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>async_read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga9766f7ede0a9fe54b96d21fe4a95f754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9766f7ede0a9fe54b96d21fe4a95f754">&#9670;&nbsp;</a></span>async_read_until() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read_until </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to asynchronously read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. If the match condition function object already indicates a match, this asynchronous operation completes immediately. The program must ensure that the stream performs no other read operations (such as async_read, async_read_until, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// The number of bytes in the streambuf&#39;s get</span></div><div class="line">  <span class="comment">// area that have been fully consumed by the</span></div><div class="line">  <span class="comment">// match function. O if an error occurred.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful async_read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent async_read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To asynchronously read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div><div class="line">    <a class="code" href="classasio_1_1basic__streambuf.html#a6c5403b9130ffe7e209769541f0e0f6b">asio::streambuf::const_buffers_type</a>&gt; <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a>;</div><div class="line"></div><div class="line">std::pair&lt;iterator, bool&gt;</div><div class="line">match_whitespace(iterator begin, iterator end)</div><div class="line">{</div><div class="line">  iterator i = begin;</div><div class="line">  <span class="keywordflow">while</span> (i != end)</div><div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div><div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div><div class="line">...</div><div class="line">asio::streambuf b;</div><div class="line"><a class="code" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">asio::async_read_until</a>(s, b, match_whitespace, handler);</div></div><!-- fragment --></dd></dl>
<p>To asynchronously read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div><div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div><div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Iterator i = begin;</div><div class="line">    <span class="keywordflow">while</span> (i != end)</div><div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div><div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">char</span> c_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div><div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div><div class="line">    : <span class="keyword">public</span> boost::true_type {};</div><div class="line">} <span class="comment">// namespace asio</span></div><div class="line">...</div><div class="line">void handler(<span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; e, std::size_t size);</div><div class="line">...</div><div class="line">asio::streambuf b;</div><div class="line"><a class="code" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">asio::async_read_until</a>(s, b, match_char(<span class="charliteral">&#39;a&#39;</span>), handler);</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
