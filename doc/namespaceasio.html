<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">asio Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceasio_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1error"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1error.html">error</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1generic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1generic.html">generic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ip"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ip.html">ip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1local"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1local.html">local</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1placeholders"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1placeholders.html">placeholders</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1posix"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1posix.html">posix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1resolver__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1resolver__errc.html">resolver_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1socket__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1socket__errc.html">socket_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1ssl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1ssl.html">ssl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1stream__errc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1stream__errc.html">stream_errc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceasio_1_1windows"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio_1_1windows.html">windows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the allocator associated with an object.  <a href="structasio_1_1associated__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits type used to obtain the executor associated with an object.  <a href="structasio_1_1associated__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1async__completion.html">async_completion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template to deduce the handler type from a CompletionToken, capture a local copy of the handler, and then create an <a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function. ">async_result</a> for the handler.  <a href="structasio_1_1async__completion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result.html">async_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for customising the behaviour of an initiating function.  <a href="classasio_1_1async__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html">async_result&lt; Handler &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use two-parameter version of <a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function. ">async_result</a>.) An interface for customising the behaviour of an initiating function.  <a href="classasio_1_1async__result_3_01Handler_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1async__result_3_01std_1_1packaged__task_3_01Result_07Args_8_8_8_08_4_00_01Signature_01_4.html">async_result&lt; std::packaged_task&lt; Result(Args...)&gt;, Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of <code><a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function. ">async_result</a></code> for <code>std::packaged_task</code>.  <a href="classasio_1_1async__result_3_01std_1_1packaged__task_3_01Result_07Args_8_8_8_08_4_00_01Signature_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1bad__executor.html">bad_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to access an empty polymorphic executor.  <a href="classasio_1_1bad__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__datagram__socket.html">basic_datagram_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides datagram-oriented socket functionality.  <a href="classasio_1_1basic__datagram__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__deadline__timer.html">basic_deadline_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__deadline__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__io__object.html">basic_io_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all I/O objects.  <a href="classasio_1_1basic__io__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__raw__socket.html">basic_raw_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides raw-oriented socket functionality.  <a href="classasio_1_1basic__raw__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__seq__packet__socket.html">basic_seq_packet_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides sequenced packet socket functionality.  <a href="classasio_1_1basic__seq__packet__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket.html">basic_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides socket functionality.  <a href="classasio_1_1basic__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__acceptor.html">basic_socket_acceptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the ability to accept new connections.  <a href="classasio_1_1basic__socket__acceptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__iostream.html">basic_socket_iostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream interface for a socket.  <a href="classasio_1_1basic__socket__iostream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__socket__streambuf.html">basic_socket_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iostream streambuf for a socket.  <a href="classasio_1_1basic__socket__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__stream__socket.html">basic_stream_socket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides stream-oriented socket functionality.  <a href="classasio_1_1basic__stream__socket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically resizable buffer class based on std::streambuf.  <a href="classasio_1_1basic__streambuf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__streambuf__ref.html">basic_streambuf_ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> to the dynamic buffer sequence type requirements.  <a href="classasio_1_1basic__streambuf__ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides waitable timer functionality.  <a href="classasio_1_1basic__waitable__timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object the represents the currently executing coroutine.  <a href="classasio_1_1basic__yield__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__read__stream.html">buffered_read_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read-related operations of a stream.  <a href="classasio_1_1buffered__read__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__stream.html">buffered_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the read- and write-related operations of a stream.  <a href="classasio_1_1buffered__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffered__write__stream.html">buffered_write_stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds buffering to the write-related operations of a stream.  <a href="classasio_1_1buffered__write__stream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random access iterator over the bytes in a buffer sequence.  <a href="classasio_1_1buffers__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that cannot be modified.  <a href="classasio_1_1const__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1const__buffers__1.html">const_buffers_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>.) Adapts a single non-modifiable buffer so that it meets the requirements of the ConstBufferSequence concept.  <a href="classasio_1_1const__buffers__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1coroutine.html">coroutine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides support for implementing stackless coroutines.  <a href="classasio_1_1coroutine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a basic_string to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__string__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapt a vector to the DynamicBuffer requirements.  <a href="classasio_1_1dynamic__vector__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__category.html">error_category</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all error categories.  <a href="classasio_1_1error__category.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1error__code.html">error_code</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to represent an error code value.  <a href="classasio_1_1error__code.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1execution__context.html">execution_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A context for function object execution.  <a href="classasio_1_1execution__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polymorphic wrapper for executors.  <a href="classasio_1_1executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type, similar to std::nothrow_t, used to disambiguate constructors that accept executor arguments.  <a href="structasio_1_1executor__arg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A call wrapper type to bind an executor of type <code>Executor</code> to an object of type <code>T</code>.  <a href="classasio_1_1executor__binder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object of type <code><a class="el" href="classasio_1_1executor__work__guard.html" title="An object of type executor_work_guard controls ownership of executor work within a scope...">executor_work_guard</a></code> controls ownership of executor work within a scope.  <a href="classasio_1_1executor__work__guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1handler__type.html">handler_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use two-parameter version of <a class="el" href="classasio_1_1async__result.html" title="An interface for customising the behaviour of an initiating function. ">async_result</a>.) Default handler type traits provided for all completion token types.  <a href="structasio_1_1handler__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1invalid__service__owner.html">invalid_service_owner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to add a service object to an <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> where the service has a different owner.  <a href="classasio_1_1invalid__service__owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1io__context.html">io_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides core I/O functionality.  <a href="classasio_1_1io__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the ConstBufferSequence requirements.  <a href="structasio_1_1is__const__buffer__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the DynamicBuffer requirements.  <a href="structasio_1_1is__dynamic__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait used to determine whether a type is an endpoint sequence that can be used with with <code>connect</code> and <code>async_connect</code>.  <a href="structasio_1_1is__endpoint__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__executor.html">is_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structasio_1_1is__executor.html" title="The is_executor trait detects whether a type T meets the Executor type requirements. ">is_executor</a> trait detects whether a type T meets the Executor type requirements.  <a href="structasio_1_1is__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait used to determine whether a type can be used as a match condition function with read_until and async_read_until.  <a href="structasio_1_1is__match__condition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to determine whether a type satisfies the MutableBufferSequence requirements.  <a href="structasio_1_1is__mutable__buffer__sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__read__buffered.html">is_read_buffered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classasio_1_1is__read__buffered.html" title="The is_read_buffered class is a traits class that may be used to determine whether a stream type supp...">is_read_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of read data.  <a href="classasio_1_1is__read__buffered.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1is__write__buffered.html">is_write_buffered</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classasio_1_1is__write__buffered.html" title="The is_write_buffered class is a traits class that may be used to determine whether a stream type sup...">is_write_buffered</a> class is a traits class that may be used to determine whether a stream type supports buffering of written data.  <a href="classasio_1_1is__write__buffered.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a buffer that can be modified.  <a href="classasio_1_1mutable__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1mutable__buffers__1.html">mutable_buffers_1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a>.) Adapts a single modifiable buffer so that it meets the requirements of the MutableBufferSequence concept.  <a href="classasio_1_1mutable__buffers__1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1null__buffers.html">null_buffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated: Use the socket/descriptor wait() and async_wait() member functions.) An implementation of both the ConstBufferSequence and MutableBufferSequence concepts to represent a null buffer sequence.  <a href="classasio_1_1null__buffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1serial__port.html">serial_port</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides serial port functionality.  <a href="classasio_1_1serial__port.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1serial__port__base.html">serial_port_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classasio_1_1serial__port__base.html" title="The serial_port_base class is used as a base for the basic_serial_port class template so that we have...">serial_port_base</a> class is used as a base for the basic_serial_port class template so that we have a common place to define the serial port options.  <a href="classasio_1_1serial__port__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1service__already__exists.html">service_already_exists</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when trying to add a duplicate service to an <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a>.  <a href="classasio_1_1service__already__exists.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1signal__set.html">signal_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides signal functionality.  <a href="classasio_1_1signal__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1socket__base.html">socket_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classasio_1_1socket__base.html" title="The socket_base class is used as a base for the basic_stream_socket and basic_datagram_socket class t...">socket_base</a> class is used as a base for the <a class="el" href="classasio_1_1basic__stream__socket.html" title="Provides stream-oriented socket functionality. ">basic_stream_socket</a> and <a class="el" href="classasio_1_1basic__datagram__socket.html" title="Provides datagram-oriented socket functionality. ">basic_datagram_socket</a> class templates so that we have a common place to define the shutdown_type and enum.  <a href="classasio_1_1socket__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1strand.html">strand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides serialised function invocation for any executor type.  <a href="classasio_1_1strand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__context.html">system_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor context for the system executor.  <a href="classasio_1_1system__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__error.html">system_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">system_error</a> class is used to represent system conditions that prevent the library from operating correctly.  <a href="classasio_1_1system__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1system__executor.html">system_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An executor that uses arbitrary threads.  <a href="classasio_1_1system__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread.html">thread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple abstraction for starting threads.  <a href="classasio_1_1thread.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1thread__pool.html">thread_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple fixed-size thread pool.  <a href="classasio_1_1thread__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1time__traits.html">time_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time traits suitable for use with the deadline timer.  <a href="structasio_1_1time__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1time__traits_3_01boost_1_1posix__time_1_1ptime_01_4.html">time_traits&lt; boost::posix_time::ptime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time traits specialised for posix_time.  <a href="structasio_1_1time__traits_3_01boost_1_1posix__time_1_1ptime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasio_1_1use__future__t.html">use_future_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used to specify that an asynchronous operation should return a future.  <a href="classasio_1_1use__future__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1uses__executor.html">uses_executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structasio_1_1uses__executor.html" title="The uses_executor trait detects whether a type T has an associated executor that is convertible from ...">uses_executor</a> trait detects whether a type T has an associated executor that is convertible from type Executor.  <a href="structasio_1_1uses__executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structasio_1_1wait__traits.html">wait_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait traits suitable for use with the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality. ">basic_waitable_timer</a> class template.  <a href="structasio_1_1wait__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a9c1e57628983c6b9c45e9204228109b7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__deadline__timer.html">basic_deadline_timer</a>&lt; boost::posix_time::ptime &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9c1e57628983c6b9c45e9204228109b7">deadline_timer</a></td></tr>
<tr class="memdesc:a9c1e57628983c6b9c45e9204228109b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of timer. Uses a UTC clock.  <a href="#a9c1e57628983c6b9c45e9204228109b7">More...</a><br /></td></tr>
<tr class="separator:a9c1e57628983c6b9c45e9204228109b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6216b3a9aa2fcebb1283920ecca9400d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6216b3a9aa2fcebb1283920ecca9400d">high_resolution_timer</a></td></tr>
<tr class="memdesc:a6216b3a9aa2fcebb1283920ecca9400d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the high resolution clock.  <a href="#a6216b3a9aa2fcebb1283920ecca9400d">More...</a><br /></td></tr>
<tr class="separator:a6216b3a9aa2fcebb1283920ecca9400d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8904bd25ca421af4140ab7ac95b0b956"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a8904bd25ca421af4140ab7ac95b0b956">io_service</a></td></tr>
<tr class="memdesc:a8904bd25ca421af4140ab7ac95b0b956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for backwards compatibility.  <a href="#a8904bd25ca421af4140ab7ac95b0b956">More...</a><br /></td></tr>
<tr class="separator:a8904bd25ca421af4140ab7ac95b0b956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd406fa13a9313f2733660a9ce9585"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; unspecified &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#af9cd406fa13a9313f2733660a9ce9585">yield_context</a></td></tr>
<tr class="memdesc:af9cd406fa13a9313f2733660a9ce9585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context object that represents the currently executing coroutine.  <a href="#af9cd406fa13a9313f2733660a9ce9585">More...</a><br /></td></tr>
<tr class="separator:af9cd406fa13a9313f2733660a9ce9585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6056991743bf20bceb4185589dbbf08"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::steady_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac6056991743bf20bceb4185589dbbf08">steady_timer</a></td></tr>
<tr class="memdesc:ac6056991743bf20bceb4185589dbbf08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the steady clock.  <a href="#ac6056991743bf20bceb4185589dbbf08">More...</a><br /></td></tr>
<tr class="separator:ac6056991743bf20bceb4185589dbbf08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7ba348943527312eeace3492bf32ee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">streambuf</a></td></tr>
<tr class="memdesc:a6a7ba348943527312eeace3492bf32ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a>.  <a href="#a6a7ba348943527312eeace3492bf32ee">More...</a><br /></td></tr>
<tr class="separator:a6a7ba348943527312eeace3492bf32ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb97c759b605015e76963b9fb299f4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::system_clock &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9eb97c759b605015e76963b9fb299f4d">system_timer</a></td></tr>
<tr class="memdesc:a9eb97c759b605015e76963b9fb299f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a timer based on the system clock.  <a href="#a9eb97c759b605015e76963b9fb299f4d">More...</a><br /></td></tr>
<tr class="separator:a9eb97c759b605015e76963b9fb299f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a386fc622bfa786fa68ca1b144bc689db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a386fc622bfa786fa68ca1b144bc689db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a386fc622bfa786fa68ca1b144bc689db">get_associated_allocator</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:a386fc622bfa786fa68ca1b144bc689db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <a href="#a386fc622bfa786fa68ca1b144bc689db">More...</a><br /></td></tr>
<tr class="separator:a386fc622bfa786fa68ca1b144bc689db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbfe0f45f87a571cf6d699081d7c353"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator &gt; </td></tr>
<tr class="memitem:a4fbfe0f45f87a571cf6d699081d7c353"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt; T, Allocator &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4fbfe0f45f87a571cf6d699081d7c353">get_associated_allocator</a> (const T &amp;t, const Allocator &amp;a) noexcept</td></tr>
<tr class="memdesc:a4fbfe0f45f87a571cf6d699081d7c353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated allocator.  <a href="#a4fbfe0f45f87a571cf6d699081d7c353">More...</a><br /></td></tr>
<tr class="separator:a4fbfe0f45f87a571cf6d699081d7c353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83ea66f179742b157eb5cec414b5fc8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac83ea66f179742b157eb5cec414b5fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac83ea66f179742b157eb5cec414b5fc8">get_associated_executor</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:ac83ea66f179742b157eb5cec414b5fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="#ac83ea66f179742b157eb5cec414b5fc8">More...</a><br /></td></tr>
<tr class="separator:ac83ea66f179742b157eb5cec414b5fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b3e33f7e4b642de6b6e0c7826ba05f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:a70b3e33f7e4b642de6b6e0c7826ba05f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, Executor &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a70b3e33f7e4b642de6b6e0c7826ba05f">get_associated_executor</a> (const T &amp;t, const Executor &amp;ex, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0) noexcept</td></tr>
<tr class="memdesc:a70b3e33f7e4b642de6b6e0c7826ba05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="#a70b3e33f7e4b642de6b6e0c7826ba05f">More...</a><br /></td></tr>
<tr class="separator:a70b3e33f7e4b642de6b6e0c7826ba05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6178a2920a41a9707d6d63c19aee2bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ab6178a2920a41a9707d6d63c19aee2bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, typename ExecutionContext::executor_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ab6178a2920a41a9707d6d63c19aee2bd">get_associated_executor</a> (const T &amp;t, ExecutionContext &amp;ctx, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0) noexcept</td></tr>
<tr class="memdesc:ab6178a2920a41a9707d6d63c19aee2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to obtain an object's associated executor.  <a href="#ab6178a2920a41a9707d6d63c19aee2bd">More...</a><br /></td></tr>
<tr class="separator:ab6178a2920a41a9707d6d63c19aee2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1335d32bca2c34ffeac97282901a91"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename T &gt; </td></tr>
<tr class="memitem:a1c1335d32bca2c34ffeac97282901a91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; T &gt;::type, Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1c1335d32bca2c34ffeac97282901a91">bind_executor</a> (const Executor &amp;ex, T &amp;&amp;t, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a1c1335d32bca2c34ffeac97282901a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an executor of type <code>Executor</code>.  <a href="#a1c1335d32bca2c34ffeac97282901a91">More...</a><br /></td></tr>
<tr class="separator:a1c1335d32bca2c34ffeac97282901a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc0b5c2c664e4bee96528d10d52768b"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename T &gt; </td></tr>
<tr class="memitem:a7dc0b5c2c664e4bee96528d10d52768b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt; typename decay&lt; T &gt;::type, typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7dc0b5c2c664e4bee96528d10d52768b">bind_executor</a> (ExecutionContext &amp;ctx, T &amp;&amp;t, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a7dc0b5c2c664e4bee96528d10d52768b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate an object of type <code>T</code> with an execution context's executor.  <a href="#a7dc0b5c2c664e4bee96528d10d52768b">More...</a><br /></td></tr>
<tr class="separator:a7dc0b5c2c664e4bee96528d10d52768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c71e70025f3051aa08ea998504b4b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__begin.html#ga62c71e70025f3051aa08ea998504b4b3">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b)</td></tr>
<tr class="memdesc:ga62c71e70025f3051aa08ea998504b4b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="group__buffer__sequence__begin.html#ga62c71e70025f3051aa08ea998504b4b3">More...</a><br /></td></tr>
<tr class="separator:ga62c71e70025f3051aa08ea998504b4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bc1f71e9c2944a2928d30e24a3ee27d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__begin.html#ga7bc1f71e9c2944a2928d30e24a3ee27d">buffer_sequence_begin</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b)</td></tr>
<tr class="memdesc:ga7bc1f71e9c2944a2928d30e24a3ee27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="group__buffer__sequence__begin.html#ga7bc1f71e9c2944a2928d30e24a3ee27d">More...</a><br /></td></tr>
<tr class="separator:ga7bc1f71e9c2944a2928d30e24a3ee27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff19cbce472f697738d0ff6d16743887"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:gaff19cbce472f697738d0ff6d16743887"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__begin.html#gaff19cbce472f697738d0ff6d16743887">buffer_sequence_begin</a> (C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:gaff19cbce472f697738d0ff6d16743887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="group__buffer__sequence__begin.html#gaff19cbce472f697738d0ff6d16743887">More...</a><br /></td></tr>
<tr class="separator:gaff19cbce472f697738d0ff6d16743887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee4cdd3276ad8b690133e5969f7cb75"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:ga3ee4cdd3276ad8b690133e5969f7cb75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__begin.html#ga3ee4cdd3276ad8b690133e5969f7cb75">buffer_sequence_begin</a> (const C &amp;c) -&gt; decltype(c.begin())</td></tr>
<tr class="memdesc:ga3ee4cdd3276ad8b690133e5969f7cb75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first element in a buffer sequence.  <a href="group__buffer__sequence__begin.html#ga3ee4cdd3276ad8b690133e5969f7cb75">More...</a><br /></td></tr>
<tr class="separator:ga3ee4cdd3276ad8b690133e5969f7cb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a16b18f651453047d7eaab00ced4f6c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__end.html#ga2a16b18f651453047d7eaab00ced4f6c">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b)</td></tr>
<tr class="memdesc:ga2a16b18f651453047d7eaab00ced4f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="group__buffer__sequence__end.html#ga2a16b18f651453047d7eaab00ced4f6c">More...</a><br /></td></tr>
<tr class="separator:ga2a16b18f651453047d7eaab00ced4f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cef6cd5e3410cf6d3e831c116c67b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__end.html#ga59cef6cd5e3410cf6d3e831c116c67b2">buffer_sequence_end</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b)</td></tr>
<tr class="memdesc:ga59cef6cd5e3410cf6d3e831c116c67b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="group__buffer__sequence__end.html#ga59cef6cd5e3410cf6d3e831c116c67b2">More...</a><br /></td></tr>
<tr class="separator:ga59cef6cd5e3410cf6d3e831c116c67b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf11e4a06af1a6446fe49b8eb975529af"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:gaf11e4a06af1a6446fe49b8eb975529af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__end.html#gaf11e4a06af1a6446fe49b8eb975529af">buffer_sequence_end</a> (C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:gaf11e4a06af1a6446fe49b8eb975529af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="group__buffer__sequence__end.html#gaf11e4a06af1a6446fe49b8eb975529af">More...</a><br /></td></tr>
<tr class="separator:gaf11e4a06af1a6446fe49b8eb975529af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec9e9b32bc630eabf4dd00cb98c4d881"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:gaec9e9b32bc630eabf4dd00cb98c4d881"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__sequence__end.html#gaec9e9b32bc630eabf4dd00cb98c4d881">buffer_sequence_end</a> (const C &amp;c) -&gt; decltype(c.end())</td></tr>
<tr class="memdesc:gaec9e9b32bc630eabf4dd00cb98c4d881"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to one past the end element in a buffer sequence.  <a href="group__buffer__sequence__end.html#gaec9e9b32bc630eabf4dd00cb98c4d881">More...</a><br /></td></tr>
<tr class="separator:gaec9e9b32bc630eabf4dd00cb98c4d881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> (const BufferSequence &amp;b) noexcept</td></tr>
<tr class="memdesc:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of bytes in a buffer sequence.  <a href="#a32ffb00a82a2cb0dcbb976e02d82cc79">More...</a><br /></td></tr>
<tr class="separator:a32ffb00a82a2cb0dcbb976e02d82cc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:ga8365a4bf9ba53918c758263fd3b0fb36"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__cast.html#ga8365a4bf9ba53918c758263fd3b0fb36">buffer_cast</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga8365a4bf9ba53918c758263fd3b0fb36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="group__buffer__cast.html#ga8365a4bf9ba53918c758263fd3b0fb36">More...</a><br /></td></tr>
<tr class="separator:ga8365a4bf9ba53918c758263fd3b0fb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga240b9552e7e1deb855c98e11583b88a5"><td class="memTemplParams" colspan="2">template&lt;typename PointerToPodType &gt; </td></tr>
<tr class="memitem:ga240b9552e7e1deb855c98e11583b88a5"><td class="memTemplItemLeft" align="right" valign="top">PointerToPodType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__cast.html#ga240b9552e7e1deb855c98e11583b88a5">buffer_cast</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga240b9552e7e1deb855c98e11583b88a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a non-modifiable buffer to a specified pointer to POD type.  <a href="group__buffer__cast.html#ga240b9552e7e1deb855c98e11583b88a5">More...</a><br /></td></tr>
<tr class="separator:ga240b9552e7e1deb855c98e11583b88a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">More...</a><br /></td></tr>
<tr class="separator:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa154e97970d6ca2f7b46c8454ae3bc92">buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaa154e97970d6ca2f7b46c8454ae3bc92">More...</a><br /></td></tr>
<tr class="separator:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5d431482687028800c05f4c2535232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaac5d431482687028800c05f4c2535232">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:gaac5d431482687028800c05f4c2535232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaac5d431482687028800c05f4c2535232">More...</a><br /></td></tr>
<tr class="separator:gaac5d431482687028800c05f4c2535232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f97fced1515eb82081ed7d2398529f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0f97fced1515eb82081ed7d2398529f1">buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga0f97fced1515eb82081ed7d2398529f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga0f97fced1515eb82081ed7d2398529f1">More...</a><br /></td></tr>
<tr class="separator:ga0f97fced1515eb82081ed7d2398529f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867ffafcd0ebe84f62d498112ec246bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga867ffafcd0ebe84f62d498112ec246bd">buffer</a> (void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga867ffafcd0ebe84f62d498112ec246bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="group__buffer.html#ga867ffafcd0ebe84f62d498112ec246bd">More...</a><br /></td></tr>
<tr class="separator:ga867ffafcd0ebe84f62d498112ec246bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf81ee11f9b0d1a68f08f2d9c571f9acc">buffer</a> (const void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaf81ee11f9b0d1a68f08f2d9c571f9acc">More...</a><br /></td></tr>
<tr class="separator:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0aa1e5f994b98f12949ae5c55924242a">buffer</a> (PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:ga0aa1e5f994b98f12949ae5c55924242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga0aa1e5f994b98f12949ae5c55924242a">More...</a><br /></td></tr>
<tr class="separator:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa0e1013294f22ec8ee81521862d687"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga1aa0e1013294f22ec8ee81521862d687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga1aa0e1013294f22ec8ee81521862d687">buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga1aa0e1013294f22ec8ee81521862d687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga1aa0e1013294f22ec8ee81521862d687">More...</a><br /></td></tr>
<tr class="separator:ga1aa0e1013294f22ec8ee81521862d687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0c0d134c4c3c470408356aae0ffb7a79">buffer</a> (const PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga0c0d134c4c3c470408356aae0ffb7a79">More...</a><br /></td></tr>
<tr class="separator:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae93df9ca5cfd5d82be0164a94d7882ac">buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae93df9ca5cfd5d82be0164a94d7882ac">More...</a><br /></td></tr>
<tr class="separator:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8093a10b52d82679a6c5627b79c78750"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga8093a10b52d82679a6c5627b79c78750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga8093a10b52d82679a6c5627b79c78750">buffer</a> (boost::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga8093a10b52d82679a6c5627b79c78750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga8093a10b52d82679a6c5627b79c78750">More...</a><br /></td></tr>
<tr class="separator:ga8093a10b52d82679a6c5627b79c78750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa55516d60be9eebc98cacdf905bab28"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaaa55516d60be9eebc98cacdf905bab28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaaa55516d60be9eebc98cacdf905bab28">buffer</a> (boost::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaaa55516d60be9eebc98cacdf905bab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaaa55516d60be9eebc98cacdf905bab28">More...</a><br /></td></tr>
<tr class="separator:gaaa55516d60be9eebc98cacdf905bab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf4667ac7f1fa2f0fa5a0e48789ad5ca9">buffer</a> (boost::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf4667ac7f1fa2f0fa5a0e48789ad5ca9">More...</a><br /></td></tr>
<tr class="separator:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97eddb2e10decd611411f8a9e157962"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gab97eddb2e10decd611411f8a9e157962"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gab97eddb2e10decd611411f8a9e157962">buffer</a> (boost::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gab97eddb2e10decd611411f8a9e157962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gab97eddb2e10decd611411f8a9e157962">More...</a><br /></td></tr>
<tr class="separator:gab97eddb2e10decd611411f8a9e157962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b">buffer</a> (std::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b">More...</a><br /></td></tr>
<tr class="separator:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db9630ae985244402c7200966ff7632"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga4db9630ae985244402c7200966ff7632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga4db9630ae985244402c7200966ff7632">buffer</a> (std::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga4db9630ae985244402c7200966ff7632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga4db9630ae985244402c7200966ff7632">More...</a><br /></td></tr>
<tr class="separator:ga4db9630ae985244402c7200966ff7632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf62d4e4fb8423f4a8618f69b65e22795">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf62d4e4fb8423f4a8618f69b65e22795">More...</a><br /></td></tr>
<tr class="separator:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga6f7374bf1002c5334d96dc6e7a719525">buffer</a> (std::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga6f7374bf1002c5334d96dc6e7a719525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga6f7374bf1002c5334d96dc6e7a719525">More...</a><br /></td></tr>
<tr class="separator:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga62e6bdda8fda3e2eb5ffd44f2e59b2df">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga62e6bdda8fda3e2eb5ffd44f2e59b2df">More...</a><br /></td></tr>
<tr class="separator:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0e839019fc0675692b8e6a5cc99d5cf6">buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga0e839019fc0675692b8e6a5cc99d5cf6">More...</a><br /></td></tr>
<tr class="separator:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48163770f1960be8900ff8d40cf05da5"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga48163770f1960be8900ff8d40cf05da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga48163770f1960be8900ff8d40cf05da5">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga48163770f1960be8900ff8d40cf05da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga48163770f1960be8900ff8d40cf05da5">More...</a><br /></td></tr>
<tr class="separator:ga48163770f1960be8900ff8d40cf05da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7931aec47b3029d93b29fd4bdcfe72b8">buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga7931aec47b3029d93b29fd4bdcfe72b8">More...</a><br /></td></tr>
<tr class="separator:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7b7b3bc80f0021bf8f3078c4d24f52e9">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <a href="group__buffer.html#ga7b7b3bc80f0021bf8f3078c4d24f52e9">More...</a><br /></td></tr>
<tr class="separator:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga4a30b0f7c75abd8f670e95a17f3b3e58">buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga4a30b0f7c75abd8f670e95a17f3b3e58">More...</a><br /></td></tr>
<tr class="separator:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga67731e245f21364ea4c17cf42ba5a05b">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga67731e245f21364ea4c17cf42ba5a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga67731e245f21364ea4c17cf42ba5a05b">More...</a><br /></td></tr>
<tr class="separator:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae24b163833cf36598c899daaeae787c"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gaae24b163833cf36598c899daaeae787c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaae24b163833cf36598c899daaeae787c">buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaae24b163833cf36598c899daaeae787c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gaae24b163833cf36598c899daaeae787c">More...</a><br /></td></tr>
<tr class="separator:gaae24b163833cf36598c899daaeae787c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0e1354c40471dd3d796a008d3b772e6a">buffer</a> (basic_string_view&lt; Elem, Traits &gt; data) noexcept</td></tr>
<tr class="memdesc:ga0e1354c40471dd3d796a008d3b772e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string_view.  <a href="group__buffer.html#ga0e1354c40471dd3d796a008d3b772e6a">More...</a><br /></td></tr>
<tr class="separator:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga67d9cc391ca3cd9a8ed738958aa66285">buffer</a> (basic_string_view&lt; Elem, Traits &gt; data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga67d9cc391ca3cd9a8ed738958aa66285">More...</a><br /></td></tr>
<tr class="separator:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257786a4aae3ecdc25e99491a48d6d6b"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga257786a4aae3ecdc25e99491a48d6d6b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dynamic__buffer.html#ga257786a4aae3ecdc25e99491a48d6d6b">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga257786a4aae3ecdc25e99491a48d6d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <a href="group__dynamic__buffer.html#ga257786a4aae3ecdc25e99491a48d6d6b">More...</a><br /></td></tr>
<tr class="separator:ga257786a4aae3ecdc25e99491a48d6d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5eda0dc06acd81709e3e1a7ebec0899a"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga5eda0dc06acd81709e3e1a7ebec0899a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__string__buffer.html">dynamic_string_buffer</a>&lt; Elem, Traits, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dynamic__buffer.html#ga5eda0dc06acd81709e3e1a7ebec0899a">dynamic_buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:ga5eda0dc06acd81709e3e1a7ebec0899a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given string.  <a href="group__dynamic__buffer.html#ga5eda0dc06acd81709e3e1a7ebec0899a">More...</a><br /></td></tr>
<tr class="separator:ga5eda0dc06acd81709e3e1a7ebec0899a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91646d8d802047f75f4084365d83085b"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:ga91646d8d802047f75f4084365d83085b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dynamic__buffer.html#ga91646d8d802047f75f4084365d83085b">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga91646d8d802047f75f4084365d83085b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <a href="group__dynamic__buffer.html#ga91646d8d802047f75f4084365d83085b">More...</a><br /></td></tr>
<tr class="separator:ga91646d8d802047f75f4084365d83085b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae542136bf9beeb083a24f786c62f2b8f"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Allocator &gt; </td></tr>
<tr class="memitem:gae542136bf9beeb083a24f786c62f2b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1dynamic__vector__buffer.html">dynamic_vector_buffer</a>&lt; Elem, Allocator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__dynamic__buffer.html#gae542136bf9beeb083a24f786c62f2b8f">dynamic_buffer</a> (std::vector&lt; Elem, Allocator &gt; &amp;data, std::size_t max_size) noexcept</td></tr>
<tr class="memdesc:gae542136bf9beeb083a24f786c62f2b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new dynamic buffer that represents the given vector.  <a href="group__dynamic__buffer.html#gae542136bf9beeb083a24f786c62f2b8f">More...</a><br /></td></tr>
<tr class="separator:gae542136bf9beeb083a24f786c62f2b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga9ab876ca15e1fd4f5f12caa8e0cac327">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source) noexcept</td></tr>
<tr class="memdesc:ga9ab876ca15e1fd4f5f12caa8e0cac327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies bytes from a source buffer sequence to a target buffer sequence.  <a href="group__buffer__copy.html#ga9ab876ca15e1fd4f5f12caa8e0cac327">More...</a><br /></td></tr>
<tr class="separator:ga9ab876ca15e1fd4f5f12caa8e0cac327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplParams" colspan="2">template&lt;typename MutableBufferSequence , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga4f84f2c9b443140a1b8693c5491ffde4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer__copy.html#ga4f84f2c9b443140a1b8693c5491ffde4">buffer_copy</a> (const MutableBufferSequence &amp;target, const ConstBufferSequence &amp;source, std::size_t max_bytes_to_copy) noexcept</td></tr>
<tr class="memdesc:ga4f84f2c9b443140a1b8693c5491ffde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a limited number of bytes from a source buffer sequence to a target buffer sequence.  <a href="group__buffer__copy.html#ga4f84f2c9b443140a1b8693c5491ffde4">More...</a><br /></td></tr>
<tr class="separator:ga4f84f2c9b443140a1b8693c5491ffde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a9d6099d23e9bf78b2b1ad82d164d3d7e">buffers_begin</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the beginning of the buffers' data.  <a href="#a9d6099d23e9bf78b2b1ad82d164d3d7e">More...</a><br /></td></tr>
<tr class="separator:a9d6099d23e9bf78b2b1ad82d164d3d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplParams" colspan="2">template&lt;typename BufferSequence &gt; </td></tr>
<tr class="memitem:a2ef4b181d4561848de38fac7907d4a0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt; BufferSequence &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ef4b181d4561848de38fac7907d4a0b">buffers_end</a> (const BufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:a2ef4b181d4561848de38fac7907d4a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an iterator representing the end of the buffers' data.  <a href="#a2ef4b181d4561848de38fac7907d4a0b">More...</a><br /></td></tr>
<tr class="separator:a2ef4b181d4561848de38fac7907d4a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750bf6e293973be0ed8e2c7a085457f7"><td class="memItemLeft" align="right" valign="top">unspecified&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#ga750bf6e293973be0ed8e2c7a085457f7">transfer_all</a> ()</td></tr>
<tr class="memdesc:ga750bf6e293973be0ed8e2c7a085457f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a completion condition function object that indicates that a read or write operation should continue until all of the data has been transferred, or until an error occurs.  <a href="group__completion__condition.html#ga750bf6e293973be0ed8e2c7a085457f7">More...</a><br /></td></tr>
<tr class="separator:ga750bf6e293973be0ed8e2c7a085457f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba1ed43445276e2b563a59663ca26cd"><td class="memItemLeft" align="right" valign="top">unspecified&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#gadba1ed43445276e2b563a59663ca26cd">transfer_at_least</a> (std::size_t minimum)</td></tr>
<tr class="memdesc:gadba1ed43445276e2b563a59663ca26cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a completion condition function object that indicates that a read or write operation should continue until a minimum number of bytes has been transferred, or until an error occurs.  <a href="group__completion__condition.html#gadba1ed43445276e2b563a59663ca26cd">More...</a><br /></td></tr>
<tr class="separator:gadba1ed43445276e2b563a59663ca26cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d5f3bef9c8b514b4c9b7f312be24875"><td class="memItemLeft" align="right" valign="top">unspecified&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__completion__condition.html#ga2d5f3bef9c8b514b4c9b7f312be24875">transfer_exactly</a> (std::size_t size)</td></tr>
<tr class="memdesc:ga2d5f3bef9c8b514b4c9b7f312be24875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a completion condition function object that indicates that a read or write operation should continue until an exact number of bytes has been transferred, or until an error occurs.  <a href="group__completion__condition.html#ga2d5f3bef9c8b514b4c9b7f312be24875">More...</a><br /></td></tr>
<tr class="separator:ga2d5f3bef9c8b514b4c9b7f312be24875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga725adb77fb09fd5ba569f3fbbd65427b">More...</a><br /></td></tr>
<tr class="separator:ga725adb77fb09fd5ba569f3fbbd65427b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence &gt; </td></tr>
<tr class="memitem:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gabb07ab5112f0691f7ec319a84d8706ff">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gabb07ab5112f0691f7ec319a84d8706ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gabb07ab5112f0691f7ec319a84d8706ff">More...</a><br /></td></tr>
<tr class="separator:gabb07ab5112f0691f7ec319a84d8706ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gaac570187376d86ed0ae4e159ddd3d6b9">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gaac570187376d86ed0ae4e159ddd3d6b9">More...</a><br /></td></tr>
<tr class="separator:gaac570187376d86ed0ae4e159ddd3d6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga8fd534f58d767632b799b3ba29cb1e5d">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga8fd534f58d767632b799b3ba29cb1e5d">More...</a><br /></td></tr>
<tr class="separator:ga8fd534f58d767632b799b3ba29cb1e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gad92e38c4005f169f69e30fdbbae6bb46">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end)</td></tr>
<tr class="memdesc:gad92e38c4005f169f69e30fdbbae6bb46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gad92e38c4005f169f69e30fdbbae6bb46">More...</a><br /></td></tr>
<tr class="separator:gad92e38c4005f169f69e30fdbbae6bb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a5e651070d3127a66d87faac7521ee3"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator &gt; </td></tr>
<tr class="memitem:ga7a5e651070d3127a66d87faac7521ee3"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga7a5e651070d3127a66d87faac7521ee3">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga7a5e651070d3127a66d87faac7521ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga7a5e651070d3127a66d87faac7521ee3">More...</a><br /></td></tr>
<tr class="separator:ga7a5e651070d3127a66d87faac7521ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac43057df8f70d23e313310a19116e583"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gac43057df8f70d23e313310a19116e583"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gac43057df8f70d23e313310a19116e583">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gac43057df8f70d23e313310a19116e583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gac43057df8f70d23e313310a19116e583">More...</a><br /></td></tr>
<tr class="separator:gac43057df8f70d23e313310a19116e583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memTemplItemLeft" align="right" valign="top">Protocol::endpoint&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga35cdf789e5a013b6b63e15de08b8d4e8">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga35cdf789e5a013b6b63e15de08b8d4e8">More...</a><br /></td></tr>
<tr class="separator:ga35cdf789e5a013b6b63e15de08b8d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga531b567bb82e2abd685fcd8b54ed15a5">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga531b567bb82e2abd685fcd8b54ed15a5">More...</a><br /></td></tr>
<tr class="separator:ga531b567bb82e2abd685fcd8b54ed15a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#ga7301de14795b08258d5e3f1e0a26e9a8">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#ga7301de14795b08258d5e3f1e0a26e9a8">More...</a><br /></td></tr>
<tr class="separator:ga7301de14795b08258d5e3f1e0a26e9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gaa4f0cd4c95adf783456fb15ef701a17f">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition)</td></tr>
<tr class="memdesc:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gaa4f0cd4c95adf783456fb15ef701a17f">More...</a><br /></td></tr>
<tr class="separator:gaa4f0cd4c95adf783456fb15ef701a17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc7354011ebba2032c1b47123888838e"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition &gt; </td></tr>
<tr class="memitem:gacc7354011ebba2032c1b47123888838e"><td class="memTemplItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__connect.html#gacc7354011ebba2032c1b47123888838e">connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gacc7354011ebba2032c1b47123888838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes a socket connection by trying each endpoint in a sequence.  <a href="group__connect.html#gacc7354011ebba2032c1b47123888838e">More...</a><br /></td></tr>
<tr class="separator:gacc7354011ebba2032c1b47123888838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename RangeConnectHandler &gt; </td></tr>
<tr class="memitem:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, RangeConnectHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga982aa1d8db83ed0559ec1d6e52fe6eb1">More...</a><br /></td></tr>
<tr class="separator:ga982aa1d8db83ed0559ec1d6e52fe6eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga71fc5bf86c82a1c7cbe7add1926894c0">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, IteratorConnectHandler &amp;&amp;handler, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga71fc5bf86c82a1c7cbe7add1926894c0">More...</a><br /></td></tr>
<tr class="separator:ga71fc5bf86c82a1c7cbe7add1926894c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#gadc625bd7fc3f0f11b5dde75767c667a3">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, IteratorConnectHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#gadc625bd7fc3f0f11b5dde75767c667a3">More...</a><br /></td></tr>
<tr class="separator:gadc625bd7fc3f0f11b5dde75767c667a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename EndpointSequence , typename ConnectCondition , typename RangeConnectHandler &gt; </td></tr>
<tr class="memitem:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#gad4f64fdcdce3e6edf07f6aa796162686">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, const EndpointSequence &amp;endpoints, ConnectCondition connect_condition, RangeConnectHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; EndpointSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gad4f64fdcdce3e6edf07f6aa796162686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#gad4f64fdcdce3e6edf07f6aa796162686">More...</a><br /></td></tr>
<tr class="separator:gad4f64fdcdce3e6edf07f6aa796162686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b55f6360c5c18a93592a428b6e18262"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga7b55f6360c5c18a93592a428b6e18262"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga7b55f6360c5c18a93592a428b6e18262">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, ConnectCondition connect_condition, IteratorConnectHandler &amp;&amp;handler, typename enable_if&lt;!<a class="el" href="structasio_1_1is__endpoint__sequence.html">is_endpoint_sequence</a>&lt; Iterator &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7b55f6360c5c18a93592a428b6e18262"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Deprecated.) Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga7b55f6360c5c18a93592a428b6e18262">More...</a><br /></td></tr>
<tr class="separator:ga7b55f6360c5c18a93592a428b6e18262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9adfc01630822620058ae54cc4fada1f"><td class="memTemplParams" colspan="2">template&lt;typename Protocol , typename Iterator , typename ConnectCondition , typename IteratorConnectHandler &gt; </td></tr>
<tr class="memitem:ga9adfc01630822620058ae54cc4fada1f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__connect.html#ga9adfc01630822620058ae54cc4fada1f">async_connect</a> (<a class="el" href="classasio_1_1basic__socket.html">basic_socket</a>&lt; Protocol &gt; &amp;s, Iterator begin, Iterator end, ConnectCondition connect_condition, IteratorConnectHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga9adfc01630822620058ae54cc4fada1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously establishes a socket connection by trying each endpoint in a sequence.  <a href="group__async__connect.html#ga9adfc01630822620058ae54cc4fada1f">More...</a><br /></td></tr>
<tr class="separator:ga9adfc01630822620058ae54cc4fada1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7009a26b18abc656178932579937df"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a1d7009a26b18abc656178932579937df"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1d7009a26b18abc656178932579937df">defer</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a1d7009a26b18abc656178932579937df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a1d7009a26b18abc656178932579937df">More...</a><br /></td></tr>
<tr class="separator:a1d7009a26b18abc656178932579937df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0ea009ec8fab244941e932469c431f"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a7e0ea009ec8fab244941e932469c431f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7e0ea009ec8fab244941e932469c431f">defer</a> (const Executor &amp;ex, CompletionToken &amp;&amp;token, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a7e0ea009ec8fab244941e932469c431f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a7e0ea009ec8fab244941e932469c431f">More...</a><br /></td></tr>
<tr class="separator:a7e0ea009ec8fab244941e932469c431f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3387a741649f6bf964ecf7ca23ace261"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a3387a741649f6bf964ecf7ca23ace261"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a3387a741649f6bf964ecf7ca23ace261">defer</a> (ExecutionContext &amp;ctx, CompletionToken &amp;&amp;token, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a3387a741649f6bf964ecf7ca23ace261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a3387a741649f6bf964ecf7ca23ace261">More...</a><br /></td></tr>
<tr class="separator:a3387a741649f6bf964ecf7ca23ace261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72279c7f82dc48b33b753244fde87062"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:a72279c7f82dc48b33b753244fde87062"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a72279c7f82dc48b33b753244fde87062">dispatch</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:a72279c7f82dc48b33b753244fde87062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a72279c7f82dc48b33b753244fde87062">More...</a><br /></td></tr>
<tr class="separator:a72279c7f82dc48b33b753244fde87062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cae446daf1369b7334f99a8b2c0dab"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a47cae446daf1369b7334f99a8b2c0dab"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a47cae446daf1369b7334f99a8b2c0dab">dispatch</a> (const Executor &amp;ex, CompletionToken &amp;&amp;token, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a47cae446daf1369b7334f99a8b2c0dab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a47cae446daf1369b7334f99a8b2c0dab">More...</a><br /></td></tr>
<tr class="separator:a47cae446daf1369b7334f99a8b2c0dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1021f76e6235ca4177ff287a08d7640b"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename CompletionToken &gt; </td></tr>
<tr class="memitem:a1021f76e6235ca4177ff287a08d7640b"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1021f76e6235ca4177ff287a08d7640b">dispatch</a> (ExecutionContext &amp;ctx, CompletionToken &amp;&amp;token, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a1021f76e6235ca4177ff287a08d7640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#a1021f76e6235ca4177ff287a08d7640b">More...</a><br /></td></tr>
<tr class="separator:a1021f76e6235ca4177ff287a08d7640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1776aa9a745f4da041978ce17abc44ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1776aa9a745f4da041978ce17abc44ff">system_category</a> ()</td></tr>
<tr class="memdesc:a1776aa9a745f4da041978ce17abc44ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error category used for the system errors produced by asio.  <a href="#a1776aa9a745f4da041978ce17abc44ff">More...</a><br /></td></tr>
<tr class="separator:a1776aa9a745f4da041978ce17abc44ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a951615f7e517dd14f0a1c3ceaa538145"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:a951615f7e517dd14f0a1c3ceaa538145"><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a951615f7e517dd14f0a1c3ceaa538145">operator&lt;&lt;</a> (std::basic_ostream&lt; Elem, Traits &gt; &amp;os, const <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:a951615f7e517dd14f0a1c3ceaa538145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output an error code.  <a href="#a951615f7e517dd14f0a1c3ceaa538145">More...</a><br /></td></tr>
<tr class="separator:a951615f7e517dd14f0a1c3ceaa538145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8cfad44625677eec8330986780cfbb"><td class="memTemplParams" colspan="2">template&lt;typename Executor &gt; </td></tr>
<tr class="memitem:a4d8cfad44625677eec8330986780cfbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; Executor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a4d8cfad44625677eec8330986780cfbb">make_work_guard</a> (const Executor &amp;ex, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a4d8cfad44625677eec8330986780cfbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="#a4d8cfad44625677eec8330986780cfbb">More...</a><br /></td></tr>
<tr class="separator:a4d8cfad44625677eec8330986780cfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0026cade004fc3b852e3bc8caddedc"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a5c0026cade004fc3b852e3bc8caddedc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename ExecutionContext::executor_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5c0026cade004fc3b852e3bc8caddedc">make_work_guard</a> (ExecutionContext &amp;ctx, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a5c0026cade004fc3b852e3bc8caddedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="#a5c0026cade004fc3b852e3bc8caddedc">More...</a><br /></td></tr>
<tr class="separator:a5c0026cade004fc3b852e3bc8caddedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ff598ff9c327c6931a0584352607b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a12ff598ff9c327c6931a0584352607b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a12ff598ff9c327c6931a0584352607b8">make_work_guard</a> (const T &amp;t, typename enable_if&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a12ff598ff9c327c6931a0584352607b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="#a12ff598ff9c327c6931a0584352607b8">More...</a><br /></td></tr>
<tr class="separator:a12ff598ff9c327c6931a0584352607b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31f49981d2b709376eda7a14270b1ee"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Executor &gt; </td></tr>
<tr class="memitem:ac31f49981d2b709376eda7a14270b1ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, Executor &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac31f49981d2b709376eda7a14270b1ee">make_work_guard</a> (const T &amp;t, const Executor &amp;ex, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ac31f49981d2b709376eda7a14270b1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="#ac31f49981d2b709376eda7a14270b1ee">More...</a><br /></td></tr>
<tr class="separator:ac31f49981d2b709376eda7a14270b1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543a0a37feca0853282564be9898ea1f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:a543a0a37feca0853282564be9898ea1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt; typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt; T, typename ExecutionContext::executor_type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a543a0a37feca0853282564be9898ea1f">make_work_guard</a> (const T &amp;t, ExecutionContext &amp;ctx, typename enable_if&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a543a0a37feca0853282564be9898ea1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object.  <a href="#a543a0a37feca0853282564be9898ea1f">More...</a><br /></td></tr>
<tr class="separator:a543a0a37feca0853282564be9898ea1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825c2034d7e4609cb65e53ec2cf833bf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf">asio_handler_allocate</a> (std::size_t size,...)</td></tr>
<tr class="memdesc:a825c2034d7e4609cb65e53ec2cf833bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default allocation function for handlers.  <a href="#a825c2034d7e4609cb65e53ec2cf833bf">More...</a><br /></td></tr>
<tr class="separator:a825c2034d7e4609cb65e53ec2cf833bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1316007445a73023bc5603a69c97d9b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a> (void *pointer, std::size_t size,...)</td></tr>
<tr class="memdesc:a1316007445a73023bc5603a69c97d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default deallocation function for handlers.  <a href="#a1316007445a73023bc5603a69c97d9b7">More...</a><br /></td></tr>
<tr class="separator:a1316007445a73023bc5603a69c97d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7613e3b437b2491c154e056f1a26668f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a> (...)</td></tr>
<tr class="memdesc:a7613e3b437b2491c154e056f1a26668f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default continuation function for handlers.  <a href="#a7613e3b437b2491c154e056f1a26668f">More...</a><br /></td></tr>
<tr class="separator:a7613e3b437b2491c154e056f1a26668f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91c8e702816572ffb691ca3f60a27871"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga91c8e702816572ffb691ca3f60a27871"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asio__handler__invoke.html#ga91c8e702816572ffb691ca3f60a27871">asio_handler_invoke</a> (Function &amp;function,...)</td></tr>
<tr class="memdesc:ga91c8e702816572ffb691ca3f60a27871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for non-const function objects.  <a href="group__asio__handler__invoke.html#ga91c8e702816572ffb691ca3f60a27871">More...</a><br /></td></tr>
<tr class="separator:ga91c8e702816572ffb691ca3f60a27871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asio__handler__invoke.html#gabe759a0b25886ffc0b10ecd98bb69edd">asio_handler_invoke</a> (const Function &amp;function,...)</td></tr>
<tr class="memdesc:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default handler invocation hook used for const function objects.  <a href="group__asio__handler__invoke.html#gabe759a0b25886ffc0b10ecd98bb69edd">More...</a><br /></td></tr>
<tr class="separator:gabe759a0b25886ffc0b10ecd98bb69edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44ea116b7d8f05c9b12545eb894e139"><td class="memTemplParams" colspan="2">template&lt;typename CompletionToken &gt; </td></tr>
<tr class="memitem:ac44ea116b7d8f05c9b12545eb894e139"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ac44ea116b7d8f05c9b12545eb894e139">post</a> (CompletionToken &amp;&amp;token)</td></tr>
<tr class="memdesc:ac44ea116b7d8f05c9b12545eb894e139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#ac44ea116b7d8f05c9b12545eb894e139">More...</a><br /></td></tr>
<tr class="separator:ac44ea116b7d8f05c9b12545eb894e139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a512c911ef70e0ce54e6f4f969c6b9"><td class="memTemplParams" colspan="2">template&lt;typename Executor , typename CompletionToken &gt; </td></tr>
<tr class="memitem:ad0a512c911ef70e0ce54e6f4f969c6b9"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad0a512c911ef70e0ce54e6f4f969c6b9">post</a> (const Executor &amp;ex, CompletionToken &amp;&amp;token, typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad0a512c911ef70e0ce54e6f4f969c6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#ad0a512c911ef70e0ce54e6f4f969c6b9">More...</a><br /></td></tr>
<tr class="separator:ad0a512c911ef70e0ce54e6f4f969c6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40270764f2c2208ebcf3bd31366c6b3"><td class="memTemplParams" colspan="2">template&lt;typename ExecutionContext , typename CompletionToken &gt; </td></tr>
<tr class="memitem:ad40270764f2c2208ebcf3bd31366c6b3"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#ad40270764f2c2208ebcf3bd31366c6b3">post</a> (ExecutionContext &amp;ctx, CompletionToken &amp;&amp;token, typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ad40270764f2c2208ebcf3bd31366c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Submits a completion token or function object for execution.  <a href="#ad40270764f2c2208ebcf3bd31366c6b3">More...</a><br /></td></tr>
<tr class="separator:ad40270764f2c2208ebcf3bd31366c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6139ae5217bdda60c94939c37f6971b6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga6139ae5217bdda60c94939c37f6971b6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga6139ae5217bdda60c94939c37f6971b6">read</a> (SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga6139ae5217bdda60c94939c37f6971b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga6139ae5217bdda60c94939c37f6971b6">More...</a><br /></td></tr>
<tr class="separator:ga6139ae5217bdda60c94939c37f6971b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff9ff31b97492c326e599398599366b"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:gafff9ff31b97492c326e599398599366b"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gafff9ff31b97492c326e599398599366b">read</a> (SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gafff9ff31b97492c326e599398599366b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gafff9ff31b97492c326e599398599366b">More...</a><br /></td></tr>
<tr class="separator:gafff9ff31b97492c326e599398599366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08771e9fbf8a4e92e8b4d2cf801a428"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gae08771e9fbf8a4e92e8b4d2cf801a428"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gae08771e9fbf8a4e92e8b4d2cf801a428">read</a> (SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gae08771e9fbf8a4e92e8b4d2cf801a428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gae08771e9fbf8a4e92e8b4d2cf801a428">More...</a><br /></td></tr>
<tr class="separator:gae08771e9fbf8a4e92e8b4d2cf801a428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d04c42f9c62cfdfad22c1e47371afe"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gac2d04c42f9c62cfdfad22c1e47371afe"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gac2d04c42f9c62cfdfad22c1e47371afe">read</a> (SyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gac2d04c42f9c62cfdfad22c1e47371afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gac2d04c42f9c62cfdfad22c1e47371afe">More...</a><br /></td></tr>
<tr class="separator:gac2d04c42f9c62cfdfad22c1e47371afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cbf08148e4aee889a0ef7143100a64f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga4cbf08148e4aee889a0ef7143100a64f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga4cbf08148e4aee889a0ef7143100a64f">read</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga4cbf08148e4aee889a0ef7143100a64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga4cbf08148e4aee889a0ef7143100a64f">More...</a><br /></td></tr>
<tr class="separator:ga4cbf08148e4aee889a0ef7143100a64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8777fcc1524dfd48586f01a2b06aff92"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga8777fcc1524dfd48586f01a2b06aff92"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga8777fcc1524dfd48586f01a2b06aff92">read</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga8777fcc1524dfd48586f01a2b06aff92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga8777fcc1524dfd48586f01a2b06aff92">More...</a><br /></td></tr>
<tr class="separator:ga8777fcc1524dfd48586f01a2b06aff92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc0fa6eb5d837bb90eee8c2b8b71c02"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gafbc0fa6eb5d837bb90eee8c2b8b71c02"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gafbc0fa6eb5d837bb90eee8c2b8b71c02">read</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gafbc0fa6eb5d837bb90eee8c2b8b71c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gafbc0fa6eb5d837bb90eee8c2b8b71c02">More...</a><br /></td></tr>
<tr class="separator:gafbc0fa6eb5d837bb90eee8c2b8b71c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d045888eba6c4f38df5802f5c8aa340"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga6d045888eba6c4f38df5802f5c8aa340"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga6d045888eba6c4f38df5802f5c8aa340">read</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga6d045888eba6c4f38df5802f5c8aa340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga6d045888eba6c4f38df5802f5c8aa340">More...</a><br /></td></tr>
<tr class="separator:ga6d045888eba6c4f38df5802f5c8aa340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaaeda9d140628ff399cbe4a076cb15cee">read</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:gaaeda9d140628ff399cbe4a076cb15cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gaaeda9d140628ff399cbe4a076cb15cee">More...</a><br /></td></tr>
<tr class="separator:gaaeda9d140628ff399cbe4a076cb15cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gabc0bc3183df1291c7b2a35ec30d5428c">read</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gabc0bc3183df1291c7b2a35ec30d5428c">More...</a><br /></td></tr>
<tr class="separator:gabc0bc3183df1291c7b2a35ec30d5428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#gaeadfb55ae835155abb8b6dc11a063b54">read</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:gaeadfb55ae835155abb8b6dc11a063b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#gaeadfb55ae835155abb8b6dc11a063b54">More...</a><br /></td></tr>
<tr class="separator:gaeadfb55ae835155abb8b6dc11a063b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6038b695e95ef357b104f35a28edfe3d"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga6038b695e95ef357b104f35a28edfe3d"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read.html#ga6038b695e95ef357b104f35a28edfe3d">read</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga6038b695e95ef357b104f35a28edfe3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data from a stream before returning.  <a href="group__read.html#ga6038b695e95ef357b104f35a28edfe3d">More...</a><br /></td></tr>
<tr class="separator:ga6038b695e95ef357b104f35a28edfe3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6b5e11b28c66272a0798e336264692"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaba6b5e11b28c66272a0798e336264692"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaba6b5e11b28c66272a0798e336264692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">More...</a><br /></td></tr>
<tr class="separator:gaba6b5e11b28c66272a0798e336264692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacebde6365f9bde238fd815b42bbd295"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaacebde6365f9bde238fd815b42bbd295"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gaacebde6365f9bde238fd815b42bbd295">async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacebde6365f9bde238fd815b42bbd295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gaacebde6365f9bde238fd815b42bbd295">More...</a><br /></td></tr>
<tr class="separator:gaacebde6365f9bde238fd815b42bbd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2306cc43534d5cb31adc33a21e046333"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga2306cc43534d5cb31adc33a21e046333"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga2306cc43534d5cb31adc33a21e046333">async_read</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga2306cc43534d5cb31adc33a21e046333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga2306cc43534d5cb31adc33a21e046333">More...</a><br /></td></tr>
<tr class="separator:ga2306cc43534d5cb31adc33a21e046333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga7b42a78c024f5fe21edd07eb328d455f">async_read</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7b42a78c024f5fe21edd07eb328d455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga7b42a78c024f5fe21edd07eb328d455f">More...</a><br /></td></tr>
<tr class="separator:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga31bbf5e27f0a990a6b72693aead652e4">async_read</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga31bbf5e27f0a990a6b72693aead652e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga31bbf5e27f0a990a6b72693aead652e4">More...</a><br /></td></tr>
<tr class="separator:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gacfc05fbbcf962c93a1ff87576fc232bd">async_read</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gacfc05fbbcf962c93a1ff87576fc232bd">More...</a><br /></td></tr>
<tr class="separator:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga4ef7a26ff401494d673ad462a3f3f5c0">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#ga4ef7a26ff401494d673ad462a3f3f5c0">More...</a><br /></td></tr>
<tr class="separator:ga4ef7a26ff401494d673ad462a3f3f5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6587e766e26325457154a5dac2a0b785"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence &gt; </td></tr>
<tr class="memitem:ga6587e766e26325457154a5dac2a0b785"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga6587e766e26325457154a5dac2a0b785">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga6587e766e26325457154a5dac2a0b785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#ga6587e766e26325457154a5dac2a0b785">More...</a><br /></td></tr>
<tr class="separator:ga6587e766e26325457154a5dac2a0b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#gaa16ebd52ad98e521ea4b75676d4db9fd">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#gaa16ebd52ad98e521ea4b75676d4db9fd">More...</a><br /></td></tr>
<tr class="separator:gaa16ebd52ad98e521ea4b75676d4db9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga88604242259da9fb0bacf3c4f0cc0002">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga88604242259da9fb0bacf3c4f0cc0002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#ga88604242259da9fb0bacf3c4f0cc0002">More...</a><br /></td></tr>
<tr class="separator:ga88604242259da9fb0bacf3c4f0cc0002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac630cbca00c30cc68fcebb3e9d874df0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:gac630cbca00c30cc68fcebb3e9d874df0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#gac630cbca00c30cc68fcebb3e9d874df0">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:gac630cbca00c30cc68fcebb3e9d874df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#gac630cbca00c30cc68fcebb3e9d874df0">More...</a><br /></td></tr>
<tr class="separator:gac630cbca00c30cc68fcebb3e9d874df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9373170bb864829b4dc31f56c95024a5"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:ga9373170bb864829b4dc31f56c95024a5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga9373170bb864829b4dc31f56c95024a5">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga9373170bb864829b4dc31f56c95024a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#ga9373170bb864829b4dc31f56c95024a5">More...</a><br /></td></tr>
<tr class="separator:ga9373170bb864829b4dc31f56c95024a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69d5a3b988414af3626bc8c505bdadf"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaf69d5a3b988414af3626bc8c505bdadf"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#gaf69d5a3b988414af3626bc8c505bdadf">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:gaf69d5a3b988414af3626bc8c505bdadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#gaf69d5a3b988414af3626bc8c505bdadf">More...</a><br /></td></tr>
<tr class="separator:gaf69d5a3b988414af3626bc8c505bdadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4a8e8c9ad758e85affbb1b10a3ccdd"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga3d4a8e8c9ad758e85affbb1b10a3ccdd"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__at.html#ga3d4a8e8c9ad758e85affbb1b10a3ccdd">read_at</a> (SyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga3d4a8e8c9ad758e85affbb1b10a3ccdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to read a certain amount of data at the specified offset before returning.  <a href="group__read__at.html#ga3d4a8e8c9ad758e85affbb1b10a3ccdd">More...</a><br /></td></tr>
<tr class="separator:ga3d4a8e8c9ad758e85affbb1b10a3ccdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec1f68a70f589112ab2cc49d1e9f54c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga2ec1f68a70f589112ab2cc49d1e9f54c"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__at.html#ga2ec1f68a70f589112ab2cc49d1e9f54c">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga2ec1f68a70f589112ab2cc49d1e9f54c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data at the specified offset.  <a href="group__async__read__at.html#ga2ec1f68a70f589112ab2cc49d1e9f54c">More...</a><br /></td></tr>
<tr class="separator:ga2ec1f68a70f589112ab2cc49d1e9f54c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af88c26a7199ff02d7b67e5a766d763"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga5af88c26a7199ff02d7b67e5a766d763"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__at.html#ga5af88c26a7199ff02d7b67e5a766d763">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga5af88c26a7199ff02d7b67e5a766d763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data at the specified offset.  <a href="group__async__read__at.html#ga5af88c26a7199ff02d7b67e5a766d763">More...</a><br /></td></tr>
<tr class="separator:ga5af88c26a7199ff02d7b67e5a766d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c15a72e9eb1de49af1b62eaa3aa91f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga58c15a72e9eb1de49af1b62eaa3aa91f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__at.html#ga58c15a72e9eb1de49af1b62eaa3aa91f">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga58c15a72e9eb1de49af1b62eaa3aa91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data at the specified offset.  <a href="group__async__read__at.html#ga58c15a72e9eb1de49af1b62eaa3aa91f">More...</a><br /></td></tr>
<tr class="separator:ga58c15a72e9eb1de49af1b62eaa3aa91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c0948d4fa0a515123b70bc018346d6"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessReadDevice , typename Allocator , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gab7c0948d4fa0a515123b70bc018346d6"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__at.html#gab7c0948d4fa0a515123b70bc018346d6">async_read_at</a> (AsyncRandomAccessReadDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gab7c0948d4fa0a515123b70bc018346d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data at the specified offset.  <a href="group__async__read__at.html#gab7c0948d4fa0a515123b70bc018346d6">More...</a><br /></td></tr>
<tr class="separator:gab7c0948d4fa0a515123b70bc018346d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim)</td></tr>
<tr class="memdesc:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">More...</a><br /></td></tr>
<tr class="separator:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab238be36a9c8963d50b788e512e3fbb1"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gab238be36a9c8963d50b788e512e3fbb1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab238be36a9c8963d50b788e512e3fbb1">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab238be36a9c8963d50b788e512e3fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#gab238be36a9c8963d50b788e512e3fbb1">More...</a><br /></td></tr>
<tr class="separator:gab238be36a9c8963d50b788e512e3fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4881fd112f99dd1178b6765101fb985"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gaf4881fd112f99dd1178b6765101fb985"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaf4881fd112f99dd1178b6765101fb985">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim)</td></tr>
<tr class="memdesc:gaf4881fd112f99dd1178b6765101fb985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#gaf4881fd112f99dd1178b6765101fb985">More...</a><br /></td></tr>
<tr class="separator:gaf4881fd112f99dd1178b6765101fb985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga2040c480ce6558ddb1c05ff3a52cfa21">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#ga2040c480ce6558ddb1c05ff3a52cfa21">More...</a><br /></td></tr>
<tr class="separator:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga3b5f09ab6c213ee12c038fc97f1131ca">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr)</td></tr>
<tr class="memdesc:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga3b5f09ab6c213ee12c038fc97f1131ca">More...</a><br /></td></tr>
<tr class="separator:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa813410c45a73beecfd836a285616e29"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gaa813410c45a73beecfd836a285616e29"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaa813410c45a73beecfd836a285616e29">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaa813410c45a73beecfd836a285616e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#gaa813410c45a73beecfd836a285616e29">More...</a><br /></td></tr>
<tr class="separator:gaa813410c45a73beecfd836a285616e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65553c55ce4173159b687d52f4734cec"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga65553c55ce4173159b687d52f4734cec"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga65553c55ce4173159b687d52f4734cec">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga65553c55ce4173159b687d52f4734cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__read__until.html#ga65553c55ce4173159b687d52f4734cec">More...</a><br /></td></tr>
<tr class="separator:ga65553c55ce4173159b687d52f4734cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab4be3fe13483a1dadaabf5538a83ae2f">read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__read__until.html#gab4be3fe13483a1dadaabf5538a83ae2f">More...</a><br /></td></tr>
<tr class="separator:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>
<tr class="memdesc:ga1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">More...</a><br /></td></tr>
<tr class="separator:ga1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">More...</a><br /></td></tr>
<tr class="separator:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba922cdc00f8c09a993e2be605133f33"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaba922cdc00f8c09a993e2be605133f33"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaba922cdc00f8c09a993e2be605133f33">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim)</td></tr>
<tr class="memdesc:gaba922cdc00f8c09a993e2be605133f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gaba922cdc00f8c09a993e2be605133f33">More...</a><br /></td></tr>
<tr class="separator:gaba922cdc00f8c09a993e2be605133f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga66b8bb85583924607ab9c6484c2dc31a">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga66b8bb85583924607ab9c6484c2dc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga66b8bb85583924607ab9c6484c2dc31a">More...</a><br /></td></tr>
<tr class="separator:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga0f38ba33f1319dfa472b5ba019d0588c">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)</td></tr>
<tr class="memdesc:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga0f38ba33f1319dfa472b5ba019d0588c">More...</a><br /></td></tr>
<tr class="separator:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga9bb6fd1a4f2eec495cb367617effcb8f">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga9bb6fd1a4f2eec495cb367617effcb8f">More...</a><br /></td></tr>
<tr class="separator:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">More...</a><br /></td></tr>
<tr class="separator:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacb23419d8878f33e469e3f743c738d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">More...</a><br /></td></tr>
<tr class="separator:gaacb23419d8878f33e469e3f743c738d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga95613ed673d2d690b31e6a88ff5f465f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__async__read__until.html#ga95613ed673d2d690b31e6a88ff5f465f">More...</a><br /></td></tr>
<tr class="separator:ga95613ed673d2d690b31e6a88ff5f465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga019e323629d84d91ce485bf1051bc50e"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga019e323629d84d91ce485bf1051bc50e"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga019e323629d84d91ce485bf1051bc50e">async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga019e323629d84d91ce485bf1051bc50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__async__read__until.html#ga019e323629d84d91ce485bf1051bc50e">More...</a><br /></td></tr>
<tr class="separator:ga019e323629d84d91ce485bf1051bc50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#gaa9a35d05887ae2041fc0ea4a6115c422">async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until some part of its data matches a regular expression.  <a href="group__async__read__until.html#gaa9a35d05887ae2041fc0ea4a6115c422">More...</a><br /></td></tr>
<tr class="separator:gaa9a35d05887ae2041fc0ea4a6115c422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10641c57596debd0b85e9103e9d81f5a"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename MatchCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga10641c57596debd0b85e9103e9d81f5a"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga10641c57596debd0b85e9103e9d81f5a">async_read_until</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga10641c57596debd0b85e9103e9d81f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__async__read__until.html#ga10641c57596debd0b85e9103e9d81f5a">More...</a><br /></td></tr>
<tr class="separator:ga10641c57596debd0b85e9103e9d81f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga449c962f7e1a72fbc7c31238b2430ce8">async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter.  <a href="group__async__read__until.html#ga449c962f7e1a72fbc7c31238b2430ce8">More...</a><br /></td></tr>
<tr class="separator:ga449c962f7e1a72fbc7c31238b2430ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga2f1d0ed14ba2a45627ec587c20514f59">async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until it contains a specified delimiter.  <a href="group__async__read__until.html#ga2f1d0ed14ba2a45627ec587c20514f59">More...</a><br /></td></tr>
<tr class="separator:ga2f1d0ed14ba2a45627ec587c20514f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5f206109b7cf76ff7b5317d9795d315"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gac5f206109b7cf76ff7b5317d9795d315"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#gac5f206109b7cf76ff7b5317d9795d315">async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gac5f206109b7cf76ff7b5317d9795d315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until some part of its data matches a regular expression.  <a href="group__async__read__until.html#gac5f206109b7cf76ff7b5317d9795d315">More...</a><br /></td></tr>
<tr class="separator:gac5f206109b7cf76ff7b5317d9795d315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename MatchCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read__until.html#ga9766f7ede0a9fe54b96d21fe4a95f754">async_read_until</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read data into a streambuf until a function object indicates a match.  <a href="group__async__read__until.html#ga9766f7ede0a9fe54b96d21fe4a95f754">More...</a><br /></td></tr>
<tr class="separator:ga9766f7ede0a9fe54b96d21fe4a95f754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga921903dfccd85f12cf46b20d567c5349"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:ga921903dfccd85f12cf46b20d567c5349"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga921903dfccd85f12cf46b20d567c5349">spawn</a> (Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:ga921903dfccd85f12cf46b20d567c5349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, calling the specified handler when it completes.  <a href="group__spawn.html#ga921903dfccd85f12cf46b20d567c5349">More...</a><br /></td></tr>
<tr class="separator:ga921903dfccd85f12cf46b20d567c5349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56a9132f934f76b3aecd955988b3947f"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename Function &gt; </td></tr>
<tr class="memitem:ga56a9132f934f76b3aecd955988b3947f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga56a9132f934f76b3aecd955988b3947f">spawn</a> (Handler &amp;&amp;handler, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes(), typename enable_if&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; typename decay&lt; Handler &gt;::type &gt;::value &amp;&amp;!is_convertible&lt; Handler &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga56a9132f934f76b3aecd955988b3947f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, calling the specified handler when it completes.  <a href="group__spawn.html#ga56a9132f934f76b3aecd955988b3947f">More...</a><br /></td></tr>
<tr class="separator:ga56a9132f934f76b3aecd955988b3947f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8108ed4d6f6d58c2c85ebfe347d435ea"><td class="memTemplParams" colspan="2">template&lt;typename Handler , typename Function &gt; </td></tr>
<tr class="memitem:ga8108ed4d6f6d58c2c85ebfe347d435ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga8108ed4d6f6d58c2c85ebfe347d435ea">spawn</a> (<a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt; Handler &gt; ctx, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:ga8108ed4d6f6d58c2c85ebfe347d435ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine, inheriting the execution context of another.  <a href="group__spawn.html#ga8108ed4d6f6d58c2c85ebfe347d435ea">More...</a><br /></td></tr>
<tr class="separator:ga8108ed4d6f6d58c2c85ebfe347d435ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a79bc64b9e144e653f302964b6817f5"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Executor &gt; </td></tr>
<tr class="memitem:ga8a79bc64b9e144e653f302964b6817f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga8a79bc64b9e144e653f302964b6817f5">spawn</a> (const Executor &amp;ex, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes(), typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga8a79bc64b9e144e653f302964b6817f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given executor.  <a href="group__spawn.html#ga8a79bc64b9e144e653f302964b6817f5">More...</a><br /></td></tr>
<tr class="separator:ga8a79bc64b9e144e653f302964b6817f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0f5ce69cdd106c6c8aba350a097bc1b"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Executor &gt; </td></tr>
<tr class="memitem:gad0f5ce69cdd106c6c8aba350a097bc1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#gad0f5ce69cdd106c6c8aba350a097bc1b">spawn</a> (const <a class="el" href="classasio_1_1strand.html">strand</a>&lt; Executor &gt; &amp;ex, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:gad0f5ce69cdd106c6c8aba350a097bc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given strand.  <a href="group__spawn.html#gad0f5ce69cdd106c6c8aba350a097bc1b">More...</a><br /></td></tr>
<tr class="separator:gad0f5ce69cdd106c6c8aba350a097bc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad28f4282cb8096cd5cb4c1bd74fa9042"><td class="memTemplParams" colspan="2">template&lt;typename Function &gt; </td></tr>
<tr class="memitem:gad28f4282cb8096cd5cb4c1bd74fa9042"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#gad28f4282cb8096cd5cb4c1bd74fa9042">spawn</a> (const <a class="el" href="classasio_1_1io__context_1_1strand.html">asio::io_context::strand</a> &amp;s, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes())</td></tr>
<tr class="memdesc:gad28f4282cb8096cd5cb4c1bd74fa9042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes in the context of a strand.  <a href="group__spawn.html#gad28f4282cb8096cd5cb4c1bd74fa9042">More...</a><br /></td></tr>
<tr class="separator:gad28f4282cb8096cd5cb4c1bd74fa9042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a677acff82a6c160d9790a2c1ca8b5a"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename ExecutionContext &gt; </td></tr>
<tr class="memitem:ga1a677acff82a6c160d9790a2c1ca8b5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__spawn.html#ga1a677acff82a6c160d9790a2c1ca8b5a">spawn</a> (ExecutionContext &amp;ctx, Function &amp;&amp;function, const boost::coroutines::attributes &amp;attributes=boost::coroutines::attributes(), typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga1a677acff82a6c160d9790a2c1ca8b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new stackful coroutine that executes on a given execution context.  <a href="group__spawn.html#ga1a677acff82a6c160d9790a2c1ca8b5a">More...</a><br /></td></tr>
<tr class="separator:ga1a677acff82a6c160d9790a2c1ca8b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700a5a376b28c391c478707a8dec6b83"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga700a5a376b28c391c478707a8dec6b83"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga700a5a376b28c391c478707a8dec6b83">write</a> (SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga700a5a376b28c391c478707a8dec6b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga700a5a376b28c391c478707a8dec6b83">More...</a><br /></td></tr>
<tr class="separator:ga700a5a376b28c391c478707a8dec6b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76bea26a365e2db58363090c667ae763"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga76bea26a365e2db58363090c667ae763"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga76bea26a365e2db58363090c667ae763">write</a> (SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga76bea26a365e2db58363090c667ae763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga76bea26a365e2db58363090c667ae763">More...</a><br /></td></tr>
<tr class="separator:ga76bea26a365e2db58363090c667ae763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8386d6d624c52cc30eb22aa0021c66eb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga8386d6d624c52cc30eb22aa0021c66eb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga8386d6d624c52cc30eb22aa0021c66eb">write</a> (SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga8386d6d624c52cc30eb22aa0021c66eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga8386d6d624c52cc30eb22aa0021c66eb">More...</a><br /></td></tr>
<tr class="separator:ga8386d6d624c52cc30eb22aa0021c66eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0836b66664a36ebc7ca74f0441fc4188"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga0836b66664a36ebc7ca74f0441fc4188"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga0836b66664a36ebc7ca74f0441fc4188">write</a> (SyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga0836b66664a36ebc7ca74f0441fc4188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga0836b66664a36ebc7ca74f0441fc4188">More...</a><br /></td></tr>
<tr class="separator:ga0836b66664a36ebc7ca74f0441fc4188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8ad0515a8b0a2fbe6292e8e79580c4"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga2d8ad0515a8b0a2fbe6292e8e79580c4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga2d8ad0515a8b0a2fbe6292e8e79580c4">write</a> (SyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga2d8ad0515a8b0a2fbe6292e8e79580c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga2d8ad0515a8b0a2fbe6292e8e79580c4">More...</a><br /></td></tr>
<tr class="separator:ga2d8ad0515a8b0a2fbe6292e8e79580c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e8f6243452b114314f2f5dfd61bacc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga04e8f6243452b114314f2f5dfd61bacc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga04e8f6243452b114314f2f5dfd61bacc">write</a> (SyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga04e8f6243452b114314f2f5dfd61bacc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga04e8f6243452b114314f2f5dfd61bacc">More...</a><br /></td></tr>
<tr class="separator:ga04e8f6243452b114314f2f5dfd61bacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f47f74ab0d7202e76efeffefdc7104f"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga4f47f74ab0d7202e76efeffefdc7104f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga4f47f74ab0d7202e76efeffefdc7104f">write</a> (SyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga4f47f74ab0d7202e76efeffefdc7104f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga4f47f74ab0d7202e76efeffefdc7104f">More...</a><br /></td></tr>
<tr class="separator:ga4f47f74ab0d7202e76efeffefdc7104f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa51fd95355cf6ea4731622f4cfc125ab"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename DynamicBuffer , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaa51fd95355cf6ea4731622f4cfc125ab"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaa51fd95355cf6ea4731622f4cfc125ab">write</a> (SyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaa51fd95355cf6ea4731622f4cfc125ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#gaa51fd95355cf6ea4731622f4cfc125ab">More...</a><br /></td></tr>
<tr class="separator:gaa51fd95355cf6ea4731622f4cfc125ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85807d13da87adf48b62979f65f41152"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga85807d13da87adf48b62979f65f41152"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga85807d13da87adf48b62979f65f41152">write</a> (SyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:ga85807d13da87adf48b62979f65f41152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#ga85807d13da87adf48b62979f65f41152">More...</a><br /></td></tr>
<tr class="separator:ga85807d13da87adf48b62979f65f41152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaf72f7eddd7d4629ea2e2b7f5b7f355bc">write</a> (SyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data to a stream before returning.  <a href="group__write.html#gaf72f7eddd7d4629ea2e2b7f5b7f355bc">More...</a><br /></td></tr>
<tr class="separator:gaf72f7eddd7d4629ea2e2b7f5b7f355bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80988391fb309ee53cc557d0065550a"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:gaa80988391fb309ee53cc557d0065550a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#gaa80988391fb309ee53cc557d0065550a">write</a> (SyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:gaa80988391fb309ee53cc557d0065550a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#gaa80988391fb309ee53cc557d0065550a">More...</a><br /></td></tr>
<tr class="separator:gaa80988391fb309ee53cc557d0065550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga393e12e427f89cb932c6a2bd800236fb"><td class="memTemplParams" colspan="2">template&lt;typename SyncWriteStream , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga393e12e427f89cb932c6a2bd800236fb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write.html#ga393e12e427f89cb932c6a2bd800236fb">write</a> (SyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga393e12e427f89cb932c6a2bd800236fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data to a stream before returning.  <a href="group__write.html#ga393e12e427f89cb932c6a2bd800236fb">More...</a><br /></td></tr>
<tr class="separator:ga393e12e427f89cb932c6a2bd800236fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12f834d8db90e87db4038639f95f130"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gae12f834d8db90e87db4038639f95f130"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#gae12f834d8db90e87db4038639f95f130">async_write</a> (AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, WriteHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gae12f834d8db90e87db4038639f95f130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data to a stream.  <a href="group__async__write.html#gae12f834d8db90e87db4038639f95f130">More...</a><br /></td></tr>
<tr class="separator:gae12f834d8db90e87db4038639f95f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27762e0543cea43ac95b4eb48e80b69c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename ConstBufferSequence , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga27762e0543cea43ac95b4eb48e80b69c"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga27762e0543cea43ac95b4eb48e80b69c">async_write</a> (AsyncWriteStream &amp;s, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__const__buffer__sequence.html">is_const_buffer_sequence</a>&lt; ConstBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga27762e0543cea43ac95b4eb48e80b69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="group__async__write.html#ga27762e0543cea43ac95b4eb48e80b69c">More...</a><br /></td></tr>
<tr class="separator:ga27762e0543cea43ac95b4eb48e80b69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c445e279d410cfb2cd553c43634bd9"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gac1c445e279d410cfb2cd553c43634bd9"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#gac1c445e279d410cfb2cd553c43634bd9">async_write</a> (AsyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, WriteHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gac1c445e279d410cfb2cd553c43634bd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data to a stream.  <a href="group__async__write.html#gac1c445e279d410cfb2cd553c43634bd9">More...</a><br /></td></tr>
<tr class="separator:gac1c445e279d410cfb2cd553c43634bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9313c3d3cb60d99f23d4ebe6b6f38b6c"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename DynamicBuffer , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga9313c3d3cb60d99f23d4ebe6b6f38b6c"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga9313c3d3cb60d99f23d4ebe6b6f38b6c">async_write</a> (AsyncWriteStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga9313c3d3cb60d99f23d4ebe6b6f38b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="group__async__write.html#ga9313c3d3cb60d99f23d4ebe6b6f38b6c">More...</a><br /></td></tr>
<tr class="separator:ga9313c3d3cb60d99f23d4ebe6b6f38b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4a81d7c5a5710fb1b71ea6485ba4c4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga3d4a81d7c5a5710fb1b71ea6485ba4c4"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#ga3d4a81d7c5a5710fb1b71ea6485ba4c4">async_write</a> (AsyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga3d4a81d7c5a5710fb1b71ea6485ba4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data to a stream.  <a href="group__async__write.html#ga3d4a81d7c5a5710fb1b71ea6485ba4c4">More...</a><br /></td></tr>
<tr class="separator:ga3d4a81d7c5a5710fb1b71ea6485ba4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9014d7d3092940bfab819f7332ebde1"><td class="memTemplParams" colspan="2">template&lt;typename AsyncWriteStream , typename Allocator , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gaf9014d7d3092940bfab819f7332ebde1"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write.html#gaf9014d7d3092940bfab819f7332ebde1">async_write</a> (AsyncWriteStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gaf9014d7d3092940bfab819f7332ebde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data to a stream.  <a href="group__async__write.html#gaf9014d7d3092940bfab819f7332ebde1">More...</a><br /></td></tr>
<tr class="separator:gaf9014d7d3092940bfab819f7332ebde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd67a05a29d183782491d14aceec7d41"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:gadd67a05a29d183782491d14aceec7d41"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#gadd67a05a29d183782491d14aceec7d41">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers)</td></tr>
<tr class="memdesc:gadd67a05a29d183782491d14aceec7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#gadd67a05a29d183782491d14aceec7d41">More...</a><br /></td></tr>
<tr class="separator:gadd67a05a29d183782491d14aceec7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga8c1abcb5870505ea2a0c524a59638da0">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga8c1abcb5870505ea2a0c524a59638da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#ga8c1abcb5870505ea2a0c524a59638da0">More...</a><br /></td></tr>
<tr class="separator:ga8c1abcb5870505ea2a0c524a59638da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga3e6b2f5dd13f4273695fbf0cdec0314a">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga3e6b2f5dd13f4273695fbf0cdec0314a">More...</a><br /></td></tr>
<tr class="separator:ga3e6b2f5dd13f4273695fbf0cdec0314a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51133c1e260b8abeeed55646e765fdd6"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga51133c1e260b8abeeed55646e765fdd6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga51133c1e260b8abeeed55646e765fdd6">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga51133c1e260b8abeeed55646e765fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga51133c1e260b8abeeed55646e765fdd6">More...</a><br /></td></tr>
<tr class="separator:ga51133c1e260b8abeeed55646e765fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1db1f75a907c17918092b41f2f242104"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1db1f75a907c17918092b41f2f242104"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga1db1f75a907c17918092b41f2f242104">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b)</td></tr>
<tr class="memdesc:ga1db1f75a907c17918092b41f2f242104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#ga1db1f75a907c17918092b41f2f242104">More...</a><br /></td></tr>
<tr class="separator:ga1db1f75a907c17918092b41f2f242104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator &gt; </td></tr>
<tr class="memitem:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#gaa6f42435acf937c35ee4c81af44ee6ce">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write all of the supplied data at the specified offset before returning.  <a href="group__write__at.html#gaa6f42435acf937c35ee4c81af44ee6ce">More...</a><br /></td></tr>
<tr class="separator:gaa6f42435acf937c35ee4c81af44ee6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga2e23f5418309ba130d75f6757b7b8e15">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition)</td></tr>
<tr class="memdesc:ga2e23f5418309ba130d75f6757b7b8e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga2e23f5418309ba130d75f6757b7b8e15">More...</a><br /></td></tr>
<tr class="separator:ga2e23f5418309ba130d75f6757b7b8e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431966af634f0701ceac7f54fc1b0371"><td class="memTemplParams" colspan="2">template&lt;typename SyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition &gt; </td></tr>
<tr class="memitem:ga431966af634f0701ceac7f54fc1b0371"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__write__at.html#ga431966af634f0701ceac7f54fc1b0371">write_at</a> (SyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga431966af634f0701ceac7f54fc1b0371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a certain amount of data at a specified offset before returning.  <a href="group__write__at.html#ga431966af634f0701ceac7f54fc1b0371">More...</a><br /></td></tr>
<tr class="separator:ga431966af634f0701ceac7f54fc1b0371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga5a8bb16f508135058a13f4a62eda57b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data at the specified offset.  <a href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">More...</a><br /></td></tr>
<tr class="separator:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#ga66f04a7490faac4ebbc66c5b9ed59514">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data at the specified offset.  <a href="group__async__write__at.html#ga66f04a7490faac4ebbc66c5b9ed59514">More...</a><br /></td></tr>
<tr class="separator:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc38874d2274f01b8abeb075b1b783d"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gaacc38874d2274f01b8abeb075b1b783d"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#gaacc38874d2274f01b8abeb075b1b783d">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gaacc38874d2274f01b8abeb075b1b783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data at the specified offset.  <a href="group__async__write__at.html#gaacc38874d2274f01b8abeb075b1b783d">More...</a><br /></td></tr>
<tr class="separator:gaacc38874d2274f01b8abeb075b1b783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cc0a03a3667674bb903567afc2952d"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gae0cc0a03a3667674bb903567afc2952d"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#gae0cc0a03a3667674bb903567afc2952d">async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gae0cc0a03a3667674bb903567afc2952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data at the specified offset.  <a href="group__async__write__at.html#gae0cc0a03a3667674bb903567afc2952d">More...</a><br /></td></tr>
<tr class="separator:gae0cc0a03a3667674bb903567afc2952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b182d7effc526c41a67746f5c67665d"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a5b182d7effc526c41a67746f5c67665d"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a5b182d7effc526c41a67746f5c67665d">use_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e)</td></tr>
<tr class="separator:a5b182d7effc526c41a67746f5c67665d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372038fbe1978742fe65b07a1b2fbcd9"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a372038fbe1978742fe65b07a1b2fbcd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a372038fbe1978742fe65b07a1b2fbcd9">add_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e, Service *svc)</td></tr>
<tr class="separator:a372038fbe1978742fe65b07a1b2fbcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7c8e7883fd13e8f1c357d788817ec6"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:acd7c8e7883fd13e8f1c357d788817ec6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#acd7c8e7883fd13e8f1c357d788817ec6">has_service</a> (<a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;e)</td></tr>
<tr class="separator:acd7c8e7883fd13e8f1c357d788817ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995de102bd92cd1ce0680bb038216645"><td class="memTemplParams" colspan="2">template&lt;typename Service &gt; </td></tr>
<tr class="memitem:a995de102bd92cd1ce0680bb038216645"><td class="memTemplItemLeft" align="right" valign="top">Service &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a995de102bd92cd1ce0680bb038216645">use_service</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="separator:a995de102bd92cd1ce0680bb038216645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2ac93adef3e5af6c68d5a0ce36a31ac6">use_service&lt; detail::io_context_impl &gt;</a> (<a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;ioc)</td></tr>
<tr class="separator:a2ac93adef3e5af6c68d5a0ce36a31ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afc881c08cb4f9444f26478bc5f683dd0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classasio_1_1use__future__t.html">use_future_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#afc881c08cb4f9444f26478bc5f683dd0">use_future</a></td></tr>
<tr class="memdesc:afc881c08cb4f9444f26478bc5f683dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special value, similar to std::nothrow.  <a href="#afc881c08cb4f9444f26478bc5f683dd0">More...</a><br /></td></tr>
<tr class="separator:afc881c08cb4f9444f26478bc5f683dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d07aef5f11fbd332259ad52db3eeb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceasio.html#a2f8d07aef5f11fbd332259ad52db3eeb">executor_arg</a></td></tr>
<tr class="memdesc:a2f8d07aef5f11fbd332259ad52db3eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments.  <a href="#a2f8d07aef5f11fbd332259ad52db3eeb">More...</a><br /></td></tr>
<tr class="separator:a2f8d07aef5f11fbd332259ad52db3eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9c1e57628983c6b9c45e9204228109b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1e57628983c6b9c45e9204228109b7">&#9670;&nbsp;</a></span>deadline_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__deadline__timer.html">basic_deadline_timer</a>&lt;boost::posix_time::ptime&gt; <a class="el" href="namespaceasio.html#a9c1e57628983c6b9c45e9204228109b7">asio::deadline_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of timer. Uses a UTC clock. </p>

</div>
</div>
<a id="a6216b3a9aa2fcebb1283920ecca9400d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6216b3a9aa2fcebb1283920ecca9400d">&#9670;&nbsp;</a></span>high_resolution_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt; chrono::high_resolution_clock&gt; <a class="el" href="namespaceasio.html#a6216b3a9aa2fcebb1283920ecca9400d">asio::high_resolution_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the high resolution clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality. ">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::high_resolution_clock&gt; timer;</div></div><!-- fragment --> 
</div>
</div>
<a id="a8904bd25ca421af4140ab7ac95b0b956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8904bd25ca421af4140ab7ac95b0b956">&#9670;&nbsp;</a></span>io_service</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1io__context.html">io_context</a> <a class="el" href="namespaceasio.html#a8904bd25ca421af4140ab7ac95b0b956">asio::io_service</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for backwards compatibility. </p>

</div>
</div>
<a id="af9cd406fa13a9313f2733660a9ce9585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd406fa13a9313f2733660a9ce9585">&#9670;&nbsp;</a></span>yield_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__yield__context.html">basic_yield_context</a>&lt;unspecified&gt; <a class="el" href="namespaceasio.html#af9cd406fa13a9313f2733660a9ce9585">asio::yield_context</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context object that represents the currently executing coroutine. </p>

</div>
</div>
<a id="ac6056991743bf20bceb4185589dbbf08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6056991743bf20bceb4185589dbbf08">&#9670;&nbsp;</a></span>steady_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt;chrono::steady_clock&gt; <a class="el" href="namespaceasio.html#ac6056991743bf20bceb4185589dbbf08">asio::steady_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the steady clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality. ">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::steady_clock&gt; timer;</div></div><!-- fragment --> 
</div>
</div>
<a id="a6a7ba348943527312eeace3492bf32ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7ba348943527312eeace3492bf32ee">&#9670;&nbsp;</a></span>streambuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a> <a class="el" href="namespaceasio.html#a6a7ba348943527312eeace3492bf32ee">asio::streambuf</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for the typical usage of <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a>. </p>

</div>
</div>
<a id="a9eb97c759b605015e76963b9fb299f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb97c759b605015e76963b9fb299f4d">&#9670;&nbsp;</a></span>system_timer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classasio_1_1basic__waitable__timer.html">basic_waitable_timer</a>&lt;chrono::system_clock&gt; <a class="el" href="namespaceasio.html#a9eb97c759b605015e76963b9fb299f4d">asio::system_timer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a timer based on the system clock. </p>
<p>This typedef uses the C++11 <code>&lt;chrono&gt;</code> standard library facility, if available. Otherwise, it may use the Boost.Chrono library. To explicitly utilise Boost.Chrono, use the <a class="el" href="classasio_1_1basic__waitable__timer.html" title="Provides waitable timer functionality. ">basic_waitable_timer</a> template directly: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_waitable_timer&lt;boost::chrono::system_clock&gt; timer;</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a386fc622bfa786fa68ca1b144bc689db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386fc622bfa786fa68ca1b144bc689db">&#9670;&nbsp;</a></span>get_associated_allocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T&gt;::type asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_allocator&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a4fbfe0f45f87a571cf6d699081d7c353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbfe0f45f87a571cf6d699081d7c353">&#9670;&nbsp;</a></span>get_associated_allocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__allocator.html">associated_allocator</a>&lt;T, Allocator&gt;::type asio::get_associated_allocator </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated allocator. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_allocator&lt;T, Allocator&gt;::get(t, a)</code> </dd></dl>

</div>
</div>
<a id="ac83ea66f179742b157eb5cec414b5fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83ea66f179742b157eb5cec414b5fc8">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T&gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_executor&lt;T&gt;::get(t)</code> </dd></dl>

</div>
</div>
<a id="a70b3e33f7e4b642de6b6e0c7826ba05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b3e33f7e4b642de6b6e0c7826ba05f">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code>associated_executor&lt;T, Executor&gt;::get(t, ex)</code> </dd></dl>

</div>
</div>
<a id="ab6178a2920a41a9707d6d63c19aee2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6178a2920a41a9707d6d63c19aee2bd">&#9670;&nbsp;</a></span>get_associated_executor() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::type asio::get_associated_executor </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to obtain an object's associated executor. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="structasio_1_1associated__executor.html" title="Traits type used to obtain the executor associated with an object. ">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::get(t, ctx.get_executor())</code> </dd></dl>

</div>
</div>
<a id="a1c1335d32bca2c34ffeac97282901a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1335d32bca2c34ffeac97282901a91">&#9670;&nbsp;</a></span>bind_executor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt;typename decay&lt;T&gt;::type, Executor&gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an executor of type <code>Executor</code>. </p>

</div>
</div>
<a id="a7dc0b5c2c664e4bee96528d10d52768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc0b5c2c664e4bee96528d10d52768b">&#9670;&nbsp;</a></span>bind_executor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__binder.html">executor_binder</a>&lt;typename decay&lt;T&gt;::type, typename ExecutionContext::executor_type&gt; asio::bind_executor </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate an object of type <code>T</code> with an execution context's executor. </p>

</div>
</div>
<a id="a32ffb00a82a2cb0dcbb976e02d82cc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32ffb00a82a2cb0dcbb976e02d82cc79">&#9670;&nbsp;</a></span>buffer_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::buffer_size </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total number of bytes in a buffer sequence. </p>
<p>The <code>buffer_size</code> function determines the total size of all buffers in the buffer sequence, as if computed as follows:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">size_t</span> total_size = 0;</div><div class="line"><span class="keyword">auto</span> i = <a class="code" href="group__buffer__sequence__begin.html#ga62c71e70025f3051aa08ea998504b4b3">asio::buffer_sequence_begin</a>(buffers);</div><div class="line"><span class="keyword">auto</span> end = <a class="code" href="group__buffer__sequence__end.html#ga2a16b18f651453047d7eaab00ced4f6c">asio::buffer_sequence_end</a>(buffers);</div><div class="line"><span class="keywordflow">for</span> (; i != end; ++i)</div><div class="line">{</div><div class="line">  const_buffer b(*i);</div><div class="line">  total_size += b.<a class="code" href="classasio_1_1basic__streambuf.html#a92cd17fe1a52575f8b3aa2eb486ed9e2">size</a>();</div><div class="line">}</div><div class="line"><span class="keywordflow">return</span> total_size; </div></div><!-- fragment --><p>The <code>BufferSequence</code> template parameter may meet either of the <code>ConstBufferSequence</code> or <code>MutableBufferSequence</code> type requirements. </p>

</div>
</div>
<a id="a9d6099d23e9bf78b2b1ad82d164d3d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6099d23e9bf78b2b1ad82d164d3d7e">&#9670;&nbsp;</a></span>buffers_begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_begin </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an iterator representing the beginning of the buffers' data. </p>

</div>
</div>
<a id="a2ef4b181d4561848de38fac7907d4a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef4b181d4561848de38fac7907d4a0b">&#9670;&nbsp;</a></span>buffers_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1buffers__iterator.html">buffers_iterator</a>&lt;BufferSequence&gt; asio::buffers_end </td>
          <td>(</td>
          <td class="paramtype">const BufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an iterator representing the end of the buffers' data. </p>

</div>
</div>
<a id="a1d7009a26b18abc656178932579937df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7009a26b18abc656178932579937df">&#9670;&nbsp;</a></span>defer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::defer </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a1d7009a26b18abc656178932579937df" title="Submits a completion token or function object for execution. ">defer()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Performs <code>ex.defer(std::move(handler), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="a7e0ea009ec8fab244941e932469c431f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0ea009ec8fab244941e932469c431f">&#9670;&nbsp;</a></span>defer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::defer </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a1d7009a26b18abc656178932579937df" title="Submits a completion token or function object for execution. ">defer()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <code>make_work(ex1)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <code>ex1.dispatch(std::move(handler), alloc)</code> followed by <code>w.reset()</code>.</li>
</ul>
<ul>
<li>Performs <code>Executor(ex).defer(std::move(f), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="a3387a741649f6bf964ecf7ca23ace261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3387a741649f6bf964ecf7ca23ace261">&#9670;&nbsp;</a></span>defer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::defer </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>defer(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</code>. </dd></dl>

</div>
</div>
<a id="a72279c7f82dc48b33b753244fde87062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72279c7f82dc48b33b753244fde87062">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a72279c7f82dc48b33b753244fde87062" title="Submits a completion token or function object for execution. ">dispatch()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Performs <code>ex.dispatch(std::move(handler), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="a47cae446daf1369b7334f99a8b2c0dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47cae446daf1369b7334f99a8b2c0dab">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#a72279c7f82dc48b33b753244fde87062" title="Submits a completion token or function object for execution. ">dispatch()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <code>make_work(ex1)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <code>ex1.dispatch(std::move(handler), alloc)</code> followed by <code>w.reset()</code>.</li>
</ul>
<ul>
<li>Performs <code>Executor(ex).dispatch(std::move(f), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="a1021f76e6235ca4177ff287a08d7640b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1021f76e6235ca4177ff287a08d7640b">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::dispatch </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>dispatch(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</code>. </dd></dl>

</div>
</div>
<a id="a1776aa9a745f4da041978ce17abc44ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1776aa9a745f4da041978ce17abc44ff">&#9670;&nbsp;</a></span>system_category()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classasio_1_1error__category.html">error_category</a> &amp; asio::system_category </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error category used for the system errors produced by asio. </p>

</div>
</div>
<a id="a951615f7e517dd14f0a1c3ceaa538145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951615f7e517dd14f0a1c3ceaa538145">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt;Elem, Traits&gt;&amp; asio::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Elem, Traits &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classasio_1_1error__code.html">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output an error code. </p>

</div>
</div>
<a id="a4d8cfad44625677eec8330986780cfbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8cfad44625677eec8330986780cfbb">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;Executor&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="a5c0026cade004fc3b852e3bc8caddedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0026cade004fc3b852e3bc8caddedc">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;typename ExecutionContext::executor_type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="a12ff598ff9c327c6931a0584352607b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ff598ff9c327c6931a0584352607b8">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T&gt;::type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="ac31f49981d2b709376eda7a14270b1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31f49981d2b709376eda7a14270b1ee">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Executor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, Executor&gt;::type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="a543a0a37feca0853282564be9898ea1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543a0a37feca0853282564be9898ea1f">&#9670;&nbsp;</a></span>make_work_guard() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ExecutionContext &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a>&lt;typename <a class="el" href="structasio_1_1associated__executor.html">associated_executor</a>&lt;T, typename ExecutionContext::executor_type&gt;::type&gt; asio::make_work_guard </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt;!<a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; T &gt;::value &amp;&amp;!is_convertible&lt; T &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classasio_1_1executor__work__guard.html">executor_work_guard</a> object. </p>

</div>
</div>
<a id="a825c2034d7e4609cb65e53ec2cf833bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825c2034d7e4609cb65e53ec2cf833bf">&#9670;&nbsp;</a></span>asio_handler_allocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * asio::asio_handler_allocate </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default allocation function for handlers. </p>
<p>Asynchronous operations may need to allocate temporary objects. Since asynchronous operations have a handler function object, these temporary objects can be said to be associated with the handler.</p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for these temporary objects.</p>
<p>The default implementation of these allocation hooks uses <code>::operator new</code> and <code>::operator delete</code>.</p>
<dl class="section note"><dt>Note</dt><dd>All temporary objects associated with a handler will be deallocated before the upcall to the handler is performed. This allows the same memory to be reused for a subsequent asynchronous operation initiated by the handler.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span>* <a class="code" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf">asio_handler_allocate</a>(std::size_t size, my_handler* context)</div><div class="line">{</div><div class="line">  return ::operator <span class="keyword">new</span>(size);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceasio.html#a1316007445a73023bc5603a69c97d9b7">asio_handler_deallocate</a>(<span class="keywordtype">void</span>* pointer, std::size_t size,</div><div class="line">    my_handler* context)</div><div class="line">{</div><div class="line">  ::operator <span class="keyword">delete</span>(pointer);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a1316007445a73023bc5603a69c97d9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1316007445a73023bc5603a69c97d9b7">&#9670;&nbsp;</a></span>asio_handler_deallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void asio::asio_handler_deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default deallocation function for handlers. </p>
<p>Implement asio_handler_allocate and asio_handler_deallocate for your own handlers to provide custom allocation for the associated temporary objects.</p>
<p>The default implementation of these allocation hooks uses <code>::operator new</code> and <code>::operator delete</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceasio.html#a825c2034d7e4609cb65e53ec2cf833bf" title="Default allocation function for handlers. ">asio_handler_allocate</a>. </dd></dl>

</div>
</div>
<a id="a7613e3b437b2491c154e056f1a26668f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7613e3b437b2491c154e056f1a26668f">&#9670;&nbsp;</a></span>asio_handler_is_continuation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool asio::asio_handler_is_continuation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default continuation function for handlers. </p>
<p>Asynchronous operations may represent a continuation of the asynchronous control flow associated with the current handler. The implementation can use this knowledge to optimise scheduling of the handler.</p>
<p>Implement asio_handler_is_continuation for your own handlers to indicate when a handler represents a continuation.</p>
<p>The default implementation of the continuation hook returns <code>false</code>.</p>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="keyword">class </span>my_handler;</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> <a class="code" href="namespaceasio.html#a7613e3b437b2491c154e056f1a26668f">asio_handler_is_continuation</a>(my_handler* context)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac44ea116b7d8f05c9b12545eb894e139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44ea116b7d8f05c9b12545eb894e139">&#9670;&nbsp;</a></span>post() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::post </td>
          <td>(</td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the object's associated executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#ac44ea116b7d8f05c9b12545eb894e139" title="Submits a completion token or function object for execution. ">post()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Performs <code>ex.post(std::move(handler), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="ad0a512c911ef70e0ce54e6f4f969c6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0a512c911ef70e0ce54e6f4f969c6b9">&#9670;&nbsp;</a></span>post() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Executor , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::post </td>
          <td>(</td>
          <td class="paramtype">const Executor &amp;&#160;</td>
          <td class="paramname"><em>ex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__executor.html">is_executor</a>&lt; Executor &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<p>This function submits an object for execution using the specified executor. The function object is queued for execution, and is never called from the current thread prior to returning from <code><a class="el" href="namespaceasio.html#ac44ea116b7d8f05c9b12545eb894e139" title="Submits a completion token or function object for execution. ">post()</a></code>.</p>
<p>This function has the following effects:</p>
<ul>
<li>Constructs a function object handler of type <code>Handler</code>, initialized with <code>handler(forward&lt;CompletionToken&gt;(token))</code>.</li>
</ul>
<ul>
<li>Constructs an object <code>result</code> of type <code><a class="el" href="classasio_1_1async__result_3_01Handler_01_4.html" title="(Deprecated: Use two-parameter version of async_result.) An interface for customising the behaviour o...">async_result&lt;Handler&gt;</a></code>, initializing the object as <code>result(handler)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated executor object <code>ex1</code> by performing <code>get_associated_executor(handler)</code>.</li>
</ul>
<ul>
<li>Creates a work object <code>w</code> by performing <code>make_work(ex1)</code>.</li>
</ul>
<ul>
<li>Obtains the handler's associated allocator object <code>alloc</code> by performing <code>get_associated_allocator(handler)</code>.</li>
</ul>
<ul>
<li>Constructs a function object <code>f</code> with a function call operator that performs <code>ex1.dispatch(std::move(handler), alloc)</code> followed by <code>w.reset()</code>.</li>
</ul>
<ul>
<li>Performs <code>Executor(ex).post(std::move(f), alloc)</code>.</li>
</ul>
<ul>
<li>Returns <code>result.get()</code>. </li>
</ul>

</div>
</div>
<a id="ad40270764f2c2208ebcf3bd31366c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40270764f2c2208ebcf3bd31366c6b3">&#9670;&nbsp;</a></span>post() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutionContext , typename CompletionToken &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::post </td>
          <td>(</td>
          <td class="paramtype">ExecutionContext &amp;&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionToken &amp;&amp;&#160;</td>
          <td class="paramname"><em>token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; is_convertible&lt; ExecutionContext &amp;, <a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Submits a completion token or function object for execution. </p>
<dl class="section return"><dt>Returns</dt><dd><code>post(ctx.get_executor(), forward&lt;CompletionToken&gt;(token))</code>. </dd></dl>

</div>
</div>
<a id="a5b182d7effc526c41a67746f5c67665d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b182d7effc526c41a67746f5c67665d">&#9670;&nbsp;</a></span>use_service() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service&amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller. </dd></dl>

</div>
</div>
<a id="a372038fbe1978742fe65b07a1b2fbcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a372038fbe1978742fe65b07a1b2fbcd9">&#9670;&nbsp;</a></span>add_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void asio::add_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Service *&#160;</td>
          <td class="paramname"><em>svc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to add a service to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> object that owns the service.</td></tr>
    <tr><td class="paramname">svc</td><td>The service object. On success, ownership of the service object is transferred to the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a>. When the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> object is destroyed, it will destroy the service object by performing:<div class="fragment"><div class="line"><span class="keyword">delete</span> <span class="keyword">static_cast&lt;</span>execution_context::service*<span class="keyword">&gt;</span>(svc) </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1service__already__exists.html" title="Exception thrown when trying to add a duplicate service to an execution_context. ">asio::service_already_exists</a></td><td>Thrown if a service of the given type is already present in the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a>.</td></tr>
    <tr><td class="paramname"><a class="el" href="classasio_1_1invalid__service__owner.html" title="Exception thrown when trying to add a service object to an execution_context where the service has a ...">asio::invalid_service_owner</a></td><td>Thrown if the service's owning <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> is not the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> object specified by the <code>e</code> parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd7c8e7883fd13e8f1c357d788817ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7c8e7883fd13e8f1c357d788817ec6">&#9670;&nbsp;</a></span>has_service()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool asio::has_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1execution__context.html">execution_context</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to determine whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> contains a service object corresponding to the given service type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean indicating whether the <a class="el" href="classasio_1_1execution__context.html" title="A context for function object execution. ">execution_context</a> contains the service. </dd></dl>

</div>
</div>
<a id="a995de102bd92cd1ce0680bb038216645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995de102bd92cd1ce0680bb038216645">&#9670;&nbsp;</a></span>use_service() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Service &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Service&amp; asio::use_service </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>ioc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is used to locate a service object that corresponds to the given service type. If there is no existing implementation of the service, then the <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> will create a new instance of the service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ioc</td><td>The <a class="el" href="classasio_1_1io__context.html" title="Provides core I/O functionality. ">io_context</a> object that owns the service.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The service interface implementing the specified service type. Ownership of the service interface is not transferred to the caller.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is preserved for backwards compatibility with services that inherit from <a class="el" href="classasio_1_1io__context_1_1service.html" title="Base class for all io_context services. ">io_context::service</a>. </dd></dl>

</div>
</div>
<a id="a2ac93adef3e5af6c68d5a0ce36a31ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac93adef3e5af6c68d5a0ce36a31ac6">&#9670;&nbsp;</a></span>use_service< detail::io_context_impl >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a>&amp; <a class="el" href="namespaceasio.html#a5b182d7effc526c41a67746f5c67665d">asio::use_service</a>&lt; <a class="el" href="namespaceasio_1_1detail.html#a18464be2f80491d42628366e26c34ff7">detail::io_context_impl</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classasio_1_1io__context.html">io_context</a> &amp;&#160;</td>
          <td class="paramname"><em>ioc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afc881c08cb4f9444f26478bc5f683dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc881c08cb4f9444f26478bc5f683dd0">&#9670;&nbsp;</a></span>use_future</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classasio_1_1use__future__t.html">use_future_t</a> asio::use_future</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special value, similar to std::nothrow. </p>
<p>See the documentation for <a class="el" href="classasio_1_1use__future__t.html" title="Class used to specify that an asynchronous operation should return a future. ">asio::use_future_t</a> for a usage example. </p>

</div>
</div>
<a id="a2f8d07aef5f11fbd332259ad52db3eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8d07aef5f11fbd332259ad52db3eeb">&#9670;&nbsp;</a></span>executor_arg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structasio_1_1executor__arg__t.html">executor_arg_t</a> asio::executor_arg</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special value, similar to std::nothrow, used to disambiguate constructors that accept executor arguments. </p>
<p>See <a class="el" href="structasio_1_1executor__arg__t.html" title="A special type, similar to std::nothrow_t, used to disambiguate constructors that accept executor arg...">asio::executor_arg_t</a> and <a class="el" href="structasio_1_1uses__executor.html" title="The uses_executor trait detects whether a type T has an associated executor that is convertible from ...">asio::uses_executor</a> for more information. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
