<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::async_read</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::async_read</div>  </div>
</div><!--header-->
<div class="contents">

<p>Start an asynchronous operation to read a certain amount of data from a stream.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaba6b5e11b28c66272a0798e336264692"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaba6b5e11b28c66272a0798e336264692"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaba6b5e11b28c66272a0798e336264692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">More...</a><br /></td></tr>
<tr class="separator:gaba6b5e11b28c66272a0798e336264692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacebde6365f9bde238fd815b42bbd295"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gaacebde6365f9bde238fd815b42bbd295"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gaacebde6365f9bde238fd815b42bbd295">asio::async_read</a> (AsyncReadStream &amp;s, const MutableBufferSequence &amp;buffers, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacebde6365f9bde238fd815b42bbd295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gaacebde6365f9bde238fd815b42bbd295">More...</a><br /></td></tr>
<tr class="separator:gaacebde6365f9bde238fd815b42bbd295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2306cc43534d5cb31adc33a21e046333"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga2306cc43534d5cb31adc33a21e046333"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga2306cc43534d5cb31adc33a21e046333">asio::async_read</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga2306cc43534d5cb31adc33a21e046333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga2306cc43534d5cb31adc33a21e046333">More...</a><br /></td></tr>
<tr class="separator:ga2306cc43534d5cb31adc33a21e046333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename DynamicBuffer , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga7b42a78c024f5fe21edd07eb328d455f">asio::async_read</a> (AsyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler, typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga7b42a78c024f5fe21edd07eb328d455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga7b42a78c024f5fe21edd07eb328d455f">More...</a><br /></td></tr>
<tr class="separator:ga7b42a78c024f5fe21edd07eb328d455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </td></tr>
<tr class="memitem:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#ga31bbf5e27f0a990a6b72693aead652e4">asio::async_read</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga31bbf5e27f0a990a6b72693aead652e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#ga31bbf5e27f0a990a6b72693aead652e4">More...</a><br /></td></tr>
<tr class="separator:ga31bbf5e27f0a990a6b72693aead652e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memTemplParams" colspan="2">template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , typename ReadHandler &gt; </td></tr>
<tr class="memitem:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__read.html#gacfc05fbbcf962c93a1ff87576fc232bd">asio::async_read</a> (AsyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to read a certain amount of data from a stream.  <a href="group__async__read.html#gacfc05fbbcf962c93a1ff87576fc232bd">More...</a><br /></td></tr>
<tr class="separator:gacfc05fbbcf962c93a1ff87576fc232bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaba6b5e11b28c66272a0798e336264692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba6b5e11b28c66272a0798e336264692">&#9670;&nbsp;</a></span>async_read() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a>(s, <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size), handler);</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a>(</div><div class="line">   s, buffers,</div><div class="line">   <a class="code" href="group__completion__condition.html#ga750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),</div><div class="line">   handler); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaacebde6365f9bde238fd815b42bbd295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacebde6365f9bde238fd815b42bbd295">&#9670;&nbsp;</a></span>async_read() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename MutableBufferSequence , typename CompletionCondition , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MutableBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__mutable__buffer__sequence.html">is_mutable_buffer_sequence</a>&lt; MutableBufferSequence &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffers are full. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. The sum of the buffer sizes indicates the maximum number of bytes to read from the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div><div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To read into a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a>(s,</div><div class="line">   <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size),</div><div class="line">   <a class="code" href="group__completion__condition.html#gadba1ed43445276e2b563a59663ca26cd">asio::transfer_at_least</a>(32),</div><div class="line">   handler); </div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on reading into multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="ga2306cc43534d5cb31adc33a21e046333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2306cc43534d5cb31adc33a21e046333">&#9670;&nbsp;</a></span>async_read() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a>(</div><div class="line">   s, buffers,</div><div class="line">   <a class="code" href="group__completion__condition.html#ga750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),</div><div class="line">   handler); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga7b42a78c024f5fe21edd07eb328d455f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b42a78c024f5fe21edd07eb328d455f">&#9670;&nbsp;</a></span>async_read() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename DynamicBuffer , typename CompletionCondition , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__dynamic__buffer.html">is_dynamic_buffer</a>&lt; DynamicBuffer &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The specified dynamic buffer sequence is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div><div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31bbf5e27f0a990a6b72693aead652e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31bbf5e27f0a990a6b72693aead652e4">&#9670;&nbsp;</a></span>async_read() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This overload is equivalent to calling: <div class="fragment"><div class="line"><a class="code" href="group__async__read.html#gaba6b5e11b28c66272a0798e336264692">asio::async_read</a>(</div><div class="line">   s, b,</div><div class="line">   <a class="code" href="group__completion__condition.html#ga750bf6e293973be0ed8e2c7a085457f7">asio::transfer_all</a>(),</div><div class="line">   handler); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gacfc05fbbcf962c93a1ff87576fc232bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfc05fbbcf962c93a1ff87576fc232bd">&#9670;&nbsp;</a></span>async_read() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncReadStream , typename Allocator , typename CompletionCondition , typename ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_read </td>
          <td>(</td>
          <td class="paramtype">AsyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to read a certain amount of data from a stream. </p>
<p>This function is used to asynchronously read a certain number of bytes of data from a stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The supplied buffer is full (that is, it has reached maximum size).</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's async_read_some function, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other read operations (such as async_read, the stream's async_read_some function, or any other composed operations that perform reads) until this operation completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the AsyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object into which the data will be read. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the read operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div><div class="line">  <span class="comment">// Result of latest async_read_some operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> A return value of 0 indicates that the read operation is complete. A non-zero return value indicates the maximum number of bytes to be read on the next call to the stream's async_read_some function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>, <span class="comment">// Result of operation.</span></div><div class="line"></div><div class="line">  std::size_t bytes_transferred           <span class="comment">// Number of bytes copied into the</span></div><div class="line">                                          <span class="comment">// buffers. If an error occurred,</span></div><div class="line">                                          <span class="comment">// this will be the  number of</span></div><div class="line">                                          <span class="comment">// bytes successfully transferred</span></div><div class="line">                                          <span class="comment">// prior to the error.</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
