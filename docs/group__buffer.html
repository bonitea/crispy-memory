<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::buffer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::buffer</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab9c4237f8d208b449fe76300bf5f1da1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gab9c4237f8d208b449fe76300bf5f1da1">ASIO_MUTABLE_BUFFER</a>&#160;&#160;&#160;mutable_buffer</td></tr>
<tr class="separator:gab9c4237f8d208b449fe76300bf5f1da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b6da84e4718b534c36914c3b9b8bb73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7b6da84e4718b534c36914c3b9b8bb73">ASIO_CONST_BUFFER</a>&#160;&#160;&#160;const_buffer</td></tr>
<tr class="separator:ga7b6da84e4718b534c36914c3b9b8bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">More...</a><br /></td></tr>
<tr class="separator:ga5d7f73ad7f12e3bd045b206b1355f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaa154e97970d6ca2f7b46c8454ae3bc92">asio::buffer</a> (const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaa154e97970d6ca2f7b46c8454ae3bc92">More...</a><br /></td></tr>
<tr class="separator:gaa154e97970d6ca2f7b46c8454ae3bc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5d431482687028800c05f4c2535232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaac5d431482687028800c05f4c2535232">asio::buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:gaac5d431482687028800c05f4c2535232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#gaac5d431482687028800c05f4c2535232">More...</a><br /></td></tr>
<tr class="separator:gaac5d431482687028800c05f4c2535232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f97fced1515eb82081ed7d2398529f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0f97fced1515eb82081ed7d2398529f1">asio::buffer</a> (const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;b, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga0f97fced1515eb82081ed7d2398529f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer from an existing buffer.  <a href="group__buffer.html#ga0f97fced1515eb82081ed7d2398529f1">More...</a><br /></td></tr>
<tr class="separator:ga0f97fced1515eb82081ed7d2398529f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867ffafcd0ebe84f62d498112ec246bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga867ffafcd0ebe84f62d498112ec246bd">asio::buffer</a> (void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga867ffafcd0ebe84f62d498112ec246bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given memory range.  <a href="group__buffer.html#ga867ffafcd0ebe84f62d498112ec246bd">More...</a><br /></td></tr>
<tr class="separator:ga867ffafcd0ebe84f62d498112ec246bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf81ee11f9b0d1a68f08f2d9c571f9acc">asio::buffer</a> (const void *data, std::size_t size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given memory range.  <a href="group__buffer.html#gaf81ee11f9b0d1a68f08f2d9c571f9acc">More...</a><br /></td></tr>
<tr class="separator:gaf81ee11f9b0d1a68f08f2d9c571f9acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0aa1e5f994b98f12949ae5c55924242a">asio::buffer</a> (PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:ga0aa1e5f994b98f12949ae5c55924242a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga0aa1e5f994b98f12949ae5c55924242a">More...</a><br /></td></tr>
<tr class="separator:ga0aa1e5f994b98f12949ae5c55924242a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa0e1013294f22ec8ee81521862d687"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga1aa0e1013294f22ec8ee81521862d687"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga1aa0e1013294f22ec8ee81521862d687">asio::buffer</a> (PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga1aa0e1013294f22ec8ee81521862d687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga1aa0e1013294f22ec8ee81521862d687">More...</a><br /></td></tr>
<tr class="separator:ga1aa0e1013294f22ec8ee81521862d687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0c0d134c4c3c470408356aae0ffb7a79">asio::buffer</a> (const PodType(&amp;data)[N]) noexcept</td></tr>
<tr class="memdesc:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga0c0d134c4c3c470408356aae0ffb7a79">More...</a><br /></td></tr>
<tr class="separator:ga0c0d134c4c3c470408356aae0ffb7a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gae93df9ca5cfd5d82be0164a94d7882ac">asio::buffer</a> (const PodType(&amp;data)[N], std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gae93df9ca5cfd5d82be0164a94d7882ac">More...</a><br /></td></tr>
<tr class="separator:gae93df9ca5cfd5d82be0164a94d7882ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8093a10b52d82679a6c5627b79c78750"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga8093a10b52d82679a6c5627b79c78750"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga8093a10b52d82679a6c5627b79c78750">asio::buffer</a> (boost::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga8093a10b52d82679a6c5627b79c78750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga8093a10b52d82679a6c5627b79c78750">More...</a><br /></td></tr>
<tr class="separator:ga8093a10b52d82679a6c5627b79c78750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa55516d60be9eebc98cacdf905bab28"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaaa55516d60be9eebc98cacdf905bab28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaaa55516d60be9eebc98cacdf905bab28">asio::buffer</a> (boost::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaaa55516d60be9eebc98cacdf905bab28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaaa55516d60be9eebc98cacdf905bab28">More...</a><br /></td></tr>
<tr class="separator:gaaa55516d60be9eebc98cacdf905bab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf4667ac7f1fa2f0fa5a0e48789ad5ca9">asio::buffer</a> (boost::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf4667ac7f1fa2f0fa5a0e48789ad5ca9">More...</a><br /></td></tr>
<tr class="separator:gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab97eddb2e10decd611411f8a9e157962"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gab97eddb2e10decd611411f8a9e157962"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gab97eddb2e10decd611411f8a9e157962">asio::buffer</a> (boost::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gab97eddb2e10decd611411f8a9e157962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gab97eddb2e10decd611411f8a9e157962">More...</a><br /></td></tr>
<tr class="separator:gab97eddb2e10decd611411f8a9e157962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b">asio::buffer</a> (std::array&lt; PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b">More...</a><br /></td></tr>
<tr class="separator:gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4db9630ae985244402c7200966ff7632"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga4db9630ae985244402c7200966ff7632"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga4db9630ae985244402c7200966ff7632">asio::buffer</a> (std::array&lt; PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga4db9630ae985244402c7200966ff7632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga4db9630ae985244402c7200966ff7632">More...</a><br /></td></tr>
<tr class="separator:ga4db9630ae985244402c7200966ff7632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaf62d4e4fb8423f4a8618f69b65e22795">asio::buffer</a> (std::array&lt; const PodType, N &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#gaf62d4e4fb8423f4a8618f69b65e22795">More...</a><br /></td></tr>
<tr class="separator:gaf62d4e4fb8423f4a8618f69b65e22795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memTemplParams" colspan="2">template&lt;typename PodType , std::size_t N&gt; </td></tr>
<tr class="memitem:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga6f7374bf1002c5334d96dc6e7a719525">asio::buffer</a> (std::array&lt; const PodType, N &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga6f7374bf1002c5334d96dc6e7a719525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD array.  <a href="group__buffer.html#ga6f7374bf1002c5334d96dc6e7a719525">More...</a><br /></td></tr>
<tr class="separator:ga6f7374bf1002c5334d96dc6e7a719525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga62e6bdda8fda3e2eb5ffd44f2e59b2df">asio::buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga62e6bdda8fda3e2eb5ffd44f2e59b2df">More...</a><br /></td></tr>
<tr class="separator:ga62e6bdda8fda3e2eb5ffd44f2e59b2df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0e839019fc0675692b8e6a5cc99d5cf6">asio::buffer</a> (std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga0e839019fc0675692b8e6a5cc99d5cf6">More...</a><br /></td></tr>
<tr class="separator:ga0e839019fc0675692b8e6a5cc99d5cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48163770f1960be8900ff8d40cf05da5"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga48163770f1960be8900ff8d40cf05da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga48163770f1960be8900ff8d40cf05da5">asio::buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga48163770f1960be8900ff8d40cf05da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga48163770f1960be8900ff8d40cf05da5">More...</a><br /></td></tr>
<tr class="separator:ga48163770f1960be8900ff8d40cf05da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memTemplParams" colspan="2">template&lt;typename PodType , typename Allocator &gt; </td></tr>
<tr class="memitem:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7931aec47b3029d93b29fd4bdcfe72b8">asio::buffer</a> (const std::vector&lt; PodType, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given POD vector.  <a href="group__buffer.html#ga7931aec47b3029d93b29fd4bdcfe72b8">More...</a><br /></td></tr>
<tr class="separator:ga7931aec47b3029d93b29fd4bdcfe72b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga7b7b3bc80f0021bf8f3078c4d24f52e9">asio::buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string.  <a href="group__buffer.html#ga7b7b3bc80f0021bf8f3078c4d24f52e9">More...</a><br /></td></tr>
<tr class="separator:ga7b7b3bc80f0021bf8f3078c4d24f52e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga4a30b0f7c75abd8f670e95a17f3b3e58">asio::buffer</a> (std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga4a30b0f7c75abd8f670e95a17f3b3e58">More...</a><br /></td></tr>
<tr class="separator:ga4a30b0f7c75abd8f670e95a17f3b3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga67731e245f21364ea4c17cf42ba5a05b">asio::buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data) noexcept</td></tr>
<tr class="memdesc:ga67731e245f21364ea4c17cf42ba5a05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga67731e245f21364ea4c17cf42ba5a05b">More...</a><br /></td></tr>
<tr class="separator:ga67731e245f21364ea4c17cf42ba5a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae24b163833cf36598c899daaeae787c"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits , typename Allocator &gt; </td></tr>
<tr class="memitem:gaae24b163833cf36598c899daaeae787c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#gaae24b163833cf36598c899daaeae787c">asio::buffer</a> (const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:gaae24b163833cf36598c899daaeae787c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#gaae24b163833cf36598c899daaeae787c">More...</a><br /></td></tr>
<tr class="separator:gaae24b163833cf36598c899daaeae787c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga0e1354c40471dd3d796a008d3b772e6a">asio::buffer</a> (basic_string_view&lt; Elem, Traits &gt; data) noexcept</td></tr>
<tr class="memdesc:ga0e1354c40471dd3d796a008d3b772e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new modifiable buffer that represents the given string_view.  <a href="group__buffer.html#ga0e1354c40471dd3d796a008d3b772e6a">More...</a><br /></td></tr>
<tr class="separator:ga0e1354c40471dd3d796a008d3b772e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memTemplParams" colspan="2">template&lt;typename Elem , typename Traits &gt; </td></tr>
<tr class="memitem:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__buffer.html#ga67d9cc391ca3cd9a8ed738958aa66285">asio::buffer</a> (basic_string_view&lt; Elem, Traits &gt; data, std::size_t max_size_in_bytes) noexcept</td></tr>
<tr class="memdesc:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new non-modifiable buffer that represents the given string.  <a href="group__buffer.html#ga67d9cc391ca3cd9a8ed738958aa66285">More...</a><br /></td></tr>
<tr class="separator:ga67d9cc391ca3cd9a8ed738958aa66285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function is used to create a buffer object to represent raw memory, an array of POD elements, a vector of POD elements, or a std::string. </p>
<p>A buffer object represents a contiguous region of memory as a 2-tuple consisting of a pointer and size in bytes. A tuple of the form <code>{void*, size_t}</code> specifies a mutable (modifiable) region of memory. Similarly, a tuple of the form <code>{const void*, size_t}</code> specifies a const (non-modifiable) region of memory. These two forms correspond to the classes <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> and <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>, respectively. To mirror C++'s conversion rules, a <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> is implicitly convertible to a <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>, and the opposite conversion is not permitted.</p>
<p>The simplest use case involves reading or writing a single buffer of a specified size:</p>
<div class="fragment"><div class="line">sock.send(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size)); </div></div><!-- fragment --><p>In the above example, the return value of <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> meets the requirements of the ConstBufferSequence concept so that it may be directly passed to the socket's write function. A buffer created for modifiable memory also meets the requirements of the MutableBufferSequence concept.</p>
<p>An individual buffer may be created from a builtin array, std::vector, std::array or boost::array of POD elements. This helps prevent buffer overruns by automatically determining the size of the buffer:</p>
<div class="fragment"><div class="line"> <span class="keywordtype">char</span> d1[128];</div><div class="line"><span class="keywordtype">size_t</span> <a class="code" href="namespaceasio_1_1placeholders.html#a88d33c7a9dada222d44c76e7e5cf99b7">bytes_transferred</a> = sock.receive(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d1));</div><div class="line"></div><div class="line">std::vector&lt;char&gt; d2(128);</div><div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d2));</div><div class="line"></div><div class="line">std::array&lt;char, 128&gt; d3;</div><div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d3));</div><div class="line"></div><div class="line">boost::array&lt;char, 128&gt; d4;</div><div class="line">bytes_transferred = sock.receive(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d4)); </div></div><!-- fragment --><p>In all three cases above, the buffers created are exactly 128 bytes long. Note that a vector is <em>never</em> automatically resized when creating or using a buffer. The buffer size is determined using the vector's <code>size()</code> member function, and not its capacity.</p>
<dl class="section user"><dt>Accessing Buffer Contents</dt><dd></dd></dl>
<p>The contents of a buffer may be accessed using the <code>data()</code> and <code>size()</code> member functions:</p>
<div class="fragment"><div class="line"> <a class="code" href="classasio_1_1mutable__buffer.html">asio::mutable_buffer</a> b1 = ...;</div><div class="line">std::size_t s1 = b1.<a class="code" href="classasio_1_1mutable__buffer.html#ab9d28de61ccf85b1e87f3c2394024af8">size</a>();</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* p1 = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(b1.<a class="code" href="classasio_1_1mutable__buffer.html#ac97107b8cdf91665d7a904e0330c5665">data</a>());</div><div class="line"></div><div class="line"><a class="code" href="classasio_1_1const__buffer.html">asio::const_buffer</a> b2 = ...;</div><div class="line">std::size_t s2 = b2.<a class="code" href="classasio_1_1const__buffer.html#a2abf65b9fa9590ac238e1d17c5b46e8b">size</a>();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>* p2 = b2.<a class="code" href="classasio_1_1const__buffer.html#aac009108b503e6426b3029cfa67d4e73">data</a>(); </div></div><!-- fragment --><p>The <code>data()</code> member function permits violations of type safety, so uses of it in application code should be carefully considered.</p>
<p>For convenience, a <a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> function is provided that works with both buffers and buffer sequences (that is, types meeting the ConstBufferSequence or MutableBufferSequence type requirements). In this case, the function returns the total size of all buffers in the sequence.</p>
<dl class="section user"><dt>Buffer Copying</dt><dd></dd></dl>
<p>The <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function may be used to copy raw bytes between individual buffers and buffer sequences.</p>
<p>In particular, when used with the <a class="el" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">buffer_size</a> function, the <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> function can be used to linearise a sequence of buffers. For example:</p>
<div class="fragment"><div class="line"> vector&lt;const_buffer&gt; buffers = ...;</div><div class="line"></div><div class="line">vector&lt;unsigned char&gt; data(<a class="code" href="namespaceasio.html#a32ffb00a82a2cb0dcbb976e02d82cc79">asio::buffer_size</a>(buffers));</div><div class="line"><a class="code" href="group__buffer__copy.html#ga9ab876ca15e1fd4f5f12caa8e0cac327">asio::buffer_copy</a>(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data), buffers); </div></div><!-- fragment --><p>Note that <a class="el" href="group__buffer__copy.html">asio::buffer_copy</a> is implemented in terms of <code>memcpy</code>, and consequently it cannot be used to copy between overlapping memory regions.</p>
<dl class="section user"><dt>Buffer Invalidation</dt><dd></dd></dl>
<p>A buffer object does not have any ownership of the memory it refers to. It is the responsibility of the application to ensure the memory region remains valid until it is no longer required for an I/O operation. When the memory is no longer available, the buffer is said to have been invalidated.</p>
<p>For the <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> overloads that accept an argument of type std::vector, the buffer objects returned are invalidated by any vector operation that also invalidates all references, pointers and iterators referring to the elements in the sequence (C++ Std, 23.2.4)</p>
<p>For the <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> overloads that accept an argument of type std::basic_string, the buffer objects returned are invalidated according to the rules defined for invalidation of references, pointers and iterators referring to elements of the sequence (C++ Std, 21.3).</p>
<dl class="section user"><dt>Buffer Arithmetic</dt><dd></dd></dl>
<p>Buffer objects may be manipulated using simple arithmetic in a safe way which helps prevent buffer overruns. Consider an array initialised as follows:</p>
<div class="fragment"><div class="line">boost::array&lt;char, 6&gt; a = { <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span> }; </div></div><!-- fragment --><p>A buffer object <code>b1</code> created using:</p>
<div class="fragment"><div class="line">b1 = <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(a); </div></div><!-- fragment --><p>represents the entire array, <code>{ 'a', 'b', 'c', 'd', 'e' }</code>. An optional second argument to the <a class="el" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9" title="Create a new modifiable buffer from an existing buffer. ">asio::buffer</a> function may be used to limit the size, in bytes, of the buffer:</p>
<div class="fragment"><div class="line">b2 = <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(a, 3); </div></div><!-- fragment --><p>such that <code>b2</code> represents the data <code>{ 'a', 'b', 'c' }</code>. Even if the size argument exceeds the actual size of the array, the size of the buffer object created will be limited to the array size.</p>
<p>An offset may be applied to an existing buffer to create a new one:</p>
<div class="fragment"><div class="line">b3 = b1 + 2; </div></div><!-- fragment --><p>where <code>b3</code> will set to represent <code>{ 'c', 'd', 'e' }</code>. If the offset exceeds the size of the existing buffer, the newly created buffer will be empty.</p>
<p>Both an offset and size may be specified to create a buffer that corresponds to a specific range of bytes within an existing buffer:</p>
<div class="fragment"><div class="line">b4 = <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(b1 + 1, 3); </div></div><!-- fragment --><p>so that <code>b4</code> will refer to the bytes <code>{ 'b', 'c', 'd' }</code>.</p>
<dl class="section user"><dt>Buffers and Scatter-Gather I/O</dt><dd></dd></dl>
<p>To read or write using multiple buffers (i.e. scatter-gather I/O), multiple buffer objects may be assigned into a container that supports the MutableBufferSequence (for read) or ConstBufferSequence (for write) concepts:</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span> d1[128];</div><div class="line">std::vector&lt;char&gt; d2(128);</div><div class="line">boost::array&lt;char, 128&gt; d3;</div><div class="line"></div><div class="line">boost::array&lt;mutable_buffer, 3&gt; bufs1 = {</div><div class="line">  <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d1),</div><div class="line">  <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d2),</div><div class="line">  <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d3) };</div><div class="line">bytes_transferred = sock.receive(bufs1);</div><div class="line"></div><div class="line">std::vector&lt;const_buffer&gt; bufs2;</div><div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d1));</div><div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d2));</div><div class="line">bufs2.push_back(<a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(d3));</div><div class="line">bytes_transferred = sock.send(bufs2); </div></div><!-- fragment --> <h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab9c4237f8d208b449fe76300bf5f1da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9c4237f8d208b449fe76300bf5f1da1">&#9670;&nbsp;</a></span>ASIO_MUTABLE_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASIO_MUTABLE_BUFFER&#160;&#160;&#160;mutable_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b6da84e4718b534c36914c3b9b8bb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b6da84e4718b534c36914c3b9b8bb73">&#9670;&nbsp;</a></span>ASIO_CONST_BUFFER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASIO_CONST_BUFFER&#160;&#160;&#160;const_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5d7f73ad7f12e3bd045b206b1355f3b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d7f73ad7f12e3bd045b206b1355f3b9">&#9670;&nbsp;</a></span>buffer() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="gaa154e97970d6ca2f7b46c8454ae3bc92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa154e97970d6ca2f7b46c8454ae3bc92">&#9670;&nbsp;</a></span>buffer() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   b.data(),</div><div class="line">   min(b.size(), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaac5d431482687028800c05f4c2535232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac5d431482687028800c05f4c2535232">&#9670;&nbsp;</a></span>buffer() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffer(b)</code>. </dd></dl>

</div>
</div>
<a id="ga0f97fced1515eb82081ed7d2398529f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f97fced1515eb82081ed7d2398529f1">&#9670;&nbsp;</a></span>buffer() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer from an existing buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   b.data(),</div><div class="line">   min(b.size(), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga867ffafcd0ebe84f62d498112ec246bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867ffafcd0ebe84f62d498112ec246bd">&#9670;&nbsp;</a></span>buffer() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>mutable_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="gaf81ee11f9b0d1a68f08f2d9c571f9acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf81ee11f9b0d1a68f08f2d9c571f9acc">&#9670;&nbsp;</a></span>buffer() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given memory range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>const_buffer(data, size_in_bytes)</code>. </dd></dl>

</div>
</div>
<a id="ga0aa1e5f994b98f12949ae5c55924242a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa1e5f994b98f12949ae5c55924242a">&#9670;&nbsp;</a></span>buffer() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   static_cast&lt;void*&gt;(data),</div><div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga1aa0e1013294f22ec8ee81521862d687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa0e1013294f22ec8ee81521862d687">&#9670;&nbsp;</a></span>buffer() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   static_cast&lt;void*&gt;(data),</div><div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga0c0d134c4c3c470408356aae0ffb7a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c0d134c4c3c470408356aae0ffb7a79">&#9670;&nbsp;</a></span>buffer() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   static_cast&lt;const void*&gt;(data),</div><div class="line">   N * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gae93df9ca5cfd5d82be0164a94d7882ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae93df9ca5cfd5d82be0164a94d7882ac">&#9670;&nbsp;</a></span>buffer() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const PodType(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   static_cast&lt;const void*&gt;(data),</div><div class="line">   min(N * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga8093a10b52d82679a6c5627b79c78750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8093a10b52d82679a6c5627b79c78750">&#9670;&nbsp;</a></span>buffer() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">boost::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.data(),</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaaa55516d60be9eebc98cacdf905bab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa55516d60be9eebc98cacdf905bab28">&#9670;&nbsp;</a></span>buffer() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">boost::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.data(),</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaf4667ac7f1fa2f0fa5a0e48789ad5ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4667ac7f1fa2f0fa5a0e48789ad5ca9">&#9670;&nbsp;</a></span>buffer() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">boost::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.data(),</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gab97eddb2e10decd611411f8a9e157962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab97eddb2e10decd611411f8a9e157962">&#9670;&nbsp;</a></span>buffer() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">boost::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.data(),</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ea4ac4b0ccf6d0dcb7d6f55c9c234b">&#9670;&nbsp;</a></span>buffer() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.data(),</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga4db9630ae985244402c7200966ff7632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4db9630ae985244402c7200966ff7632">&#9670;&nbsp;</a></span>buffer() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.data(),</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="gaf62d4e4fb8423f4a8618f69b65e22795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf62d4e4fb8423f4a8618f69b65e22795">&#9670;&nbsp;</a></span>buffer() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.data(),</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga6f7374bf1002c5334d96dc6e7a719525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f7374bf1002c5334d96dc6e7a719525">&#9670;&nbsp;</a></span>buffer() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; const PodType, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD array. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.data(),</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ga62e6bdda8fda3e2eb5ffd44f2e59b2df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62e6bdda8fda3e2eb5ffd44f2e59b2df">&#9670;&nbsp;</a></span>buffer() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ga0e839019fc0675692b8e6a5cc99d5cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e839019fc0675692b8e6a5cc99d5cf6">&#9670;&nbsp;</a></span>buffer() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ga48163770f1960be8900ff8d40cf05da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48163770f1960be8900ff8d40cf05da5">&#9670;&nbsp;</a></span>buffer() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   data.size() * <span class="keyword">sizeof</span>(PodType)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ga7931aec47b3029d93b29fd4bdcfe72b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7931aec47b3029d93b29fd4bdcfe72b8">&#9670;&nbsp;</a></span>buffer() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PodType , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PodType, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given POD vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(PodType), max_size_in_bytes)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any vector operation that would also invalidate iterators. </dd></dl>

</div>
</div>
<a id="ga7b7b3bc80f0021bf8f3078c4d24f52e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b7b3bc80f0021bf8f3078c4d24f52e9">&#9670;&nbsp;</a></span>buffer() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a>(data.size() ? &amp;data[0] : 0, data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="ga4a30b0f7c75abd8f670e95a17f3b3e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a30b0f7c75abd8f670e95a17f3b3e58">&#9670;&nbsp;</a></span>buffer() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1mutable__buffer.html">mutable_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="ga67731e245f21364ea4c17cf42ba5a05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67731e245f21364ea4c17cf42ba5a05b">&#9670;&nbsp;</a></span>buffer() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a>(data.data(), data.size() * sizeof(Elem))</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="gaae24b163833cf36598c899daaeae787c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae24b163833cf36598c899daaeae787c">&#9670;&nbsp;</a></span>buffer() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits , typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">const std::basic_string&lt; Elem, Traits, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1const__buffer.html" title="Holds a buffer that cannot be modified. ">const_buffer</a> value equivalent to: <div class="fragment"><div class="line">const_buffer(</div><div class="line">   data.data(),</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div></div><!-- fragment --></dd></dl>
<dl class="section note"><dt>Note</dt><dd>The buffer is invalidated by any non-const operation called on the given string object. </dd></dl>

</div>
</div>
<a id="ga0e1354c40471dd3d796a008d3b772e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e1354c40471dd3d796a008d3b772e6a">&#9670;&nbsp;</a></span>buffer() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">basic_string_view&lt; Elem, Traits &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new modifiable buffer that represents the given string_view. </p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a>(data.size() ? &amp;data[0] : 0, data.size() * sizeof(Elem))</code>. </dd></dl>

</div>
</div>
<a id="ga67d9cc391ca3cd9a8ed738958aa66285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d9cc391ca3cd9a8ed738958aa66285">&#9670;&nbsp;</a></span>buffer() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Elem , typename Traits &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasio_1_1const__buffer.html">const_buffer</a> asio::buffer </td>
          <td>(</td>
          <td class="paramtype">basic_string_view&lt; Elem, Traits &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>max_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new non-modifiable buffer that represents the given string. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classasio_1_1mutable__buffer.html" title="Holds a buffer that can be modified. ">mutable_buffer</a> value equivalent to: <div class="fragment"><div class="line">mutable_buffer(</div><div class="line">   data.size() ? &amp;data[0] : 0,</div><div class="line">   min(data.size() * <span class="keyword">sizeof</span>(Elem), max_size_in_bytes)); </div></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
