<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::read_until</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::read_until</div>  </div>
</div><!--header-->
<div class="contents">

<p>Read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim)</td></tr>
<tr class="memdesc:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">More...</a><br /></td></tr>
<tr class="separator:ga6b5fe90ae4647674f61b3b2e80cb155c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab238be36a9c8963d50b788e512e3fbb1"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gab238be36a9c8963d50b788e512e3fbb1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab238be36a9c8963d50b788e512e3fbb1">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, char delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab238be36a9c8963d50b788e512e3fbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#gab238be36a9c8963d50b788e512e3fbb1">More...</a><br /></td></tr>
<tr class="separator:gab238be36a9c8963d50b788e512e3fbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4881fd112f99dd1178b6765101fb985"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gaf4881fd112f99dd1178b6765101fb985"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaf4881fd112f99dd1178b6765101fb985">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim)</td></tr>
<tr class="memdesc:gaf4881fd112f99dd1178b6765101fb985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#gaf4881fd112f99dd1178b6765101fb985">More...</a><br /></td></tr>
<tr class="separator:gaf4881fd112f99dd1178b6765101fb985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga2040c480ce6558ddb1c05ff3a52cfa21">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, string_view delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until it contains a specified delimiter.  <a href="group__read__until.html#ga2040c480ce6558ddb1c05ff3a52cfa21">More...</a><br /></td></tr>
<tr class="separator:ga2040c480ce6558ddb1c05ff3a52cfa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga3b5f09ab6c213ee12c038fc97f1131ca">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr)</td></tr>
<tr class="memdesc:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga3b5f09ab6c213ee12c038fc97f1131ca">More...</a><br /></td></tr>
<tr class="separator:ga3b5f09ab6c213ee12c038fc97f1131ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa813410c45a73beecfd836a285616e29"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </td></tr>
<tr class="memitem:gaa813410c45a73beecfd836a285616e29"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaa813410c45a73beecfd836a285616e29">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, const boost::regex &amp;expr, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gaa813410c45a73beecfd836a285616e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#gaa813410c45a73beecfd836a285616e29">More...</a><br /></td></tr>
<tr class="separator:gaa813410c45a73beecfd836a285616e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65553c55ce4173159b687d52f4734cec"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga65553c55ce4173159b687d52f4734cec"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga65553c55ce4173159b687d52f4734cec">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga65553c55ce4173159b687d52f4734cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__read__until.html#ga65553c55ce4173159b687d52f4734cec">More...</a><br /></td></tr>
<tr class="separator:ga65553c55ce4173159b687d52f4734cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab4be3fe13483a1dadaabf5538a83ae2f">asio::read_until</a> (SyncReadStream &amp;s, DynamicBuffer &amp;&amp;buffers, MatchCondition match_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a dynamic buffer sequence until a function object indicates a match.  <a href="group__read__until.html#gab4be3fe13483a1dadaabf5538a83ae2f">More...</a><br /></td></tr>
<tr class="separator:gab4be3fe13483a1dadaabf5538a83ae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga1aae2baa82596a6a9ad320e80b016006"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim)</td></tr>
<tr class="memdesc:ga1aae2baa82596a6a9ad320e80b016006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga1aae2baa82596a6a9ad320e80b016006">More...</a><br /></td></tr>
<tr class="separator:ga1aae2baa82596a6a9ad320e80b016006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, char delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gab9d265cc5b757caf9c9a602da2d6a3e5">More...</a><br /></td></tr>
<tr class="separator:gab9d265cc5b757caf9c9a602da2d6a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba922cdc00f8c09a993e2be605133f33"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:gaba922cdc00f8c09a993e2be605133f33"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaba922cdc00f8c09a993e2be605133f33">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim)</td></tr>
<tr class="memdesc:gaba922cdc00f8c09a993e2be605133f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#gaba922cdc00f8c09a993e2be605133f33">More...</a><br /></td></tr>
<tr class="separator:gaba922cdc00f8c09a993e2be605133f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga66b8bb85583924607ab9c6484c2dc31a">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, string_view delim, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga66b8bb85583924607ab9c6484c2dc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until it contains a specified delimiter.  <a href="group__read__until.html#ga66b8bb85583924607ab9c6484c2dc31a">More...</a><br /></td></tr>
<tr class="separator:ga66b8bb85583924607ab9c6484c2dc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga0f38ba33f1319dfa472b5ba019d0588c">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr)</td></tr>
<tr class="memdesc:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga0f38ba33f1319dfa472b5ba019d0588c">More...</a><br /></td></tr>
<tr class="separator:ga0f38ba33f1319dfa472b5ba019d0588c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator &gt; </td></tr>
<tr class="memitem:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga9bb6fd1a4f2eec495cb367617effcb8f">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, const boost::regex &amp;expr, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec)</td></tr>
<tr class="memdesc:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until some part of the data it contains matches a regular expression.  <a href="group__read__until.html#ga9bb6fd1a4f2eec495cb367617effcb8f">More...</a><br /></td></tr>
<tr class="separator:ga9bb6fd1a4f2eec495cb367617effcb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#ga5aa4b441eca98c82a144cb9a3c625db4">More...</a><br /></td></tr>
<tr class="separator:ga5aa4b441eca98c82a144cb9a3c625db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplParams" colspan="2">template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </td></tr>
<tr class="memitem:gaacb23419d8878f33e469e3f743c738d6"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">asio::read_until</a> (SyncReadStream &amp;s, <a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;b, MatchCondition match_condition, <a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;ec, typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:gaacb23419d8878f33e469e3f743c738d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data into a streambuf until a function object indicates a match.  <a href="group__read__until.html#gaacb23419d8878f33e469e3f743c738d6">More...</a><br /></td></tr>
<tr class="separator:gaacb23419d8878f33e469e3f743c738d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Read data into a dynamic buffer sequence, or into a streambuf, until it contains a delimiter, matches a regular expression, or a function object indicates a match. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6b5fe90ae4647674f61b3b2e80cb155c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b5fe90ae4647674f61b3b2e80cb155c">&#9670;&nbsp;</a></span>read_until() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a newline is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">std::string n = <a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s,</div><div class="line">    <a class="code" href="group__dynamic__buffer.html#ga257786a4aae3ecdc25e99491a48d6d6b">asio::dynamic_buffer</a>(data), <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">std::string line = data.substr(0, n);</div><div class="line">data.erase(0, n); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="gab238be36a9c8963d50b788e512e3fbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab238be36a9c8963d50b788e512e3fbb1">&#9670;&nbsp;</a></span>read_until() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="gaf4881fd112f99dd1178b6765101fb985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4881fd112f99dd1178b6765101fb985">&#9670;&nbsp;</a></span>read_until() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">std::string n = <a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s,</div><div class="line">    <a class="code" href="group__dynamic__buffer.html#ga257786a4aae3ecdc25e99491a48d6d6b">asio::dynamic_buffer</a>(data), <span class="stringliteral">&quot;\r\n&quot;</span>);</div><div class="line">std::string line = data.substr(0, n);</div><div class="line">data.erase(0, n); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga2040c480ce6558ddb1c05ff3a52cfa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2040c480ce6558ddb1c05ff3a52cfa21">&#9670;&nbsp;</a></span>read_until() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the dynamic buffer sequence contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>The dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond the delimiter. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ga3b5f09ab6c213ee12c038fc97f1131ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b5f09ab6c213ee12c038fc97f1131ca">&#9670;&nbsp;</a></span>read_until() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:</p>
<ul>
<li>A substring of the dynamic buffer sequence's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a <code>std::string</code> until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> std::string data;</div><div class="line">std::string n = <a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s,</div><div class="line">    <a class="code" href="group__dynamic__buffer.html#ga257786a4aae3ecdc25e99491a48d6d6b">asio::dynamic_buffer</a>(data), boost::regex(<span class="stringliteral">&quot;\r\n&quot;</span>));</div><div class="line">std::string line = data.substr(0, n);</div><div class="line">data.erase(0, n); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the string <code>data</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>substr</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> After the call to <code>erase</code>, the remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="gaa813410c45a73beecfd836a285616e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa813410c45a73beecfd836a285616e29">&#9670;&nbsp;</a></span>read_until() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until some part of the data it contains matches a regular expression. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until the dynamic buffer sequence's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:</p>
<ul>
<li>A substring of the dynamic buffer sequence's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the dynamic buffer sequence's get area already contains data that matches the regular expression, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ga65553c55ce4173159b687d52f4734cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65553c55ce4173159b687d52f4734cec">&#9670;&nbsp;</a></span>read_until() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until a function object indicates a match. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(<a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a> begin, <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a> end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;typename DynamicBuffer::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic_buffer's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a dynamic buffer sequence until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div><div class="line">    <a class="code" href="classasio_1_1const__buffers__1.html">asio::const_buffers_1</a>&gt; <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a>;</div><div class="line"></div><div class="line">std::pair&lt;iterator, bool&gt;</div><div class="line">match_whitespace(iterator begin, iterator end)</div><div class="line">{</div><div class="line">  iterator i = begin;</div><div class="line">  <span class="keywordflow">while</span> (i != end)</div><div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div><div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line">...</div><div class="line">std::string data;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, data, match_whitespace);</div></div><!-- fragment --></dd></dl>
<p>To read data into a <code>std::string</code> until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div><div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div><div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Iterator i = begin;</div><div class="line">    <span class="keywordflow">while</span> (i != end)</div><div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div><div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">char</span> c_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div><div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div><div class="line">    : <span class="keyword">public</span> boost::true_type {};</div><div class="line">} <span class="comment">// namespace asio</span></div><div class="line">...</div><div class="line">std::string data;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, data, match_char(<span class="charliteral">&#39;a&#39;</span>));</div></div><!-- fragment --> 
</div>
</div>
<a id="gab4be3fe13483a1dadaabf5538a83ae2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4be3fe13483a1dadaabf5538a83ae2f">&#9670;&nbsp;</a></span>read_until() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename DynamicBuffer , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DynamicBuffer &amp;&amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a dynamic buffer sequence until a function object indicates a match. </p>
<p>This function is used to read data into the specified dynamic buffer sequence until a user-defined match condition function object, when applied to the data contained in the dynamic buffer sequence, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">buffers</td><td>A dynamic buffer sequence into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;DynamicBuffer::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the dynamic buffer sequence's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the dynamic buffer sequence may contain additional data beyond that which matched the function object. An application will typically leave that data in the dynamic buffer sequence for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
<a id="ga1aae2baa82596a6a9ad320e80b016006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aae2baa82596a6a9ad320e80b016006">&#9670;&nbsp;</a></span>read_until() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, b, <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line">std::istream is(&amp;b);</div><div class="line">std::string line;</div><div class="line">std::getline(is, line); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="gab9d265cc5b757caf9c9a602da2d6a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9d265cc5b757caf9c9a602da2d6a3e5">&#9670;&nbsp;</a></span>read_until() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter character.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="gaba922cdc00f8c09a993e2be605133f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba922cdc00f8c09a993e2be605133f33">&#9670;&nbsp;</a></span>read_until() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a newline is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, b, <span class="stringliteral">&quot;\r\n&quot;</span>);</div><div class="line">std::istream is(&amp;b);</div><div class="line">std::string line;</div><div class="line">std::getline(is, line); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the delimiter: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the delimiter, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga66b8bb85583924607ab9c6484c2dc31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66b8bb85583924607ab9c6484c2dc31a">&#9670;&nbsp;</a></span>read_until() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string_view&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until it contains a specified delimiter. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains the specified delimiter. The call will block until one of the following conditions is true:</p>
<ul>
<li>The get area of the streambuf contains the specified delimiter.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains the delimiter, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">delim</td><td>The delimiter string.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the delimiter. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond the delimiter. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ga0f38ba33f1319dfa472b5ba019d0588c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f38ba33f1319dfa472b5ba019d0588c">&#9670;&nbsp;</a></span>read_until() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until some part of the data it contains matches a regular expression. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:</p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd></dl>
<dl class="section user"><dt>Example</dt><dd>To read data into a streambuf until a CR-LF sequence is encountered: <div class="fragment"><div class="line"> <a class="code" href="classasio_1_1basic__streambuf.html">asio::streambuf</a> b;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, b, boost::regex(<span class="stringliteral">&quot;\r\n&quot;</span>));</div><div class="line">std::istream is(&amp;b);</div><div class="line">std::string line;</div><div class="line">std::getline(is, line); </div></div><!-- fragment --> After the <code>read_until</code> operation completes successfully, the buffer <code>b</code> contains the data which matched the regular expression: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> The call to <code>std::getline</code> then extracts the data up to and including the match, so that the string <code>line</code> contains: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>, ..., <span class="charliteral">&#39;c&#39;</span>, <span class="charliteral">&#39;\r&#39;</span>, <span class="charliteral">&#39;\n&#39;</span> } </div></div><!-- fragment --> The remaining data is left in the buffer <code>b</code> as follows: <div class="fragment"><div class="line">{ <span class="charliteral">&#39;d&#39;</span>, <span class="charliteral">&#39;e&#39;</span>, ... } </div></div><!-- fragment --> This data may be the start of a new line, to be extracted by a subsequent <code>read_until</code> operation. </dd></dl>

</div>
</div>
<a id="ga9bb6fd1a4f2eec495cb367617effcb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bb6fd1a4f2eec495cb367617effcb8f">&#9670;&nbsp;</a></span>read_until() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::regex &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until some part of the data it contains matches a regular expression. </p>
<p>This function is used to read data into the specified streambuf until the streambuf's get area contains some data that matches a regular expression. The call will block until one of the following conditions is true:</p>
<ul>
<li>A substring of the streambuf's get area matches the regular expression.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the streambuf's get area already contains data that matches the regular expression, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">expr</td><td>The regular expression.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area up to and including the substring that matches the regular expression. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the regular expression. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine. </dd></dl>

</div>
</div>
<a id="ga5aa4b441eca98c82a144cb9a3c625db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aa4b441eca98c82a144cb9a3c625db4">&#9670;&nbsp;</a></span>read_until() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classasio_1_1system__error.html" title="The system_error class is used to represent system conditions that prevent the library from operating...">asio::system_error</a></td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd>To read data into a streambuf until whitespace is encountered: <div class="fragment"><div class="line"> <span class="keyword">typedef</span> <a class="code" href="classasio_1_1buffers__iterator.html">asio::buffers_iterator</a>&lt;</div><div class="line">    <a class="code" href="classasio_1_1basic__streambuf.html#a6c5403b9130ffe7e209769541f0e0f6b">asio::streambuf::const_buffers_type</a>&gt; <a class="code" href="namespaceasio_1_1placeholders.html#a4aaf36b46c92386e9216df53718f9d67">iterator</a>;</div><div class="line"></div><div class="line">std::pair&lt;iterator, bool&gt;</div><div class="line">match_whitespace(iterator begin, iterator end)</div><div class="line">{</div><div class="line">  iterator i = begin;</div><div class="line">  <span class="keywordflow">while</span> (i != end)</div><div class="line">    <span class="keywordflow">if</span> (std::isspace(*i++))</div><div class="line">      <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">  <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">}</div><div class="line">...</div><div class="line">asio::streambuf b;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, b, match_whitespace);</div></div><!-- fragment --></dd></dl>
<p>To read data into a streambuf until a matching character is found: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>match_char</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> match_char(<span class="keywordtype">char</span> c) : c_(c) {}</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</div><div class="line">  std::pair&lt;Iterator, bool&gt; operator()(</div><div class="line">      Iterator begin, Iterator end)<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    Iterator i = begin;</div><div class="line">    <span class="keywordflow">while</span> (i != end)</div><div class="line">      <span class="keywordflow">if</span> (c_ == *i++)</div><div class="line">        <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">return</span> std::make_pair(i, <span class="keyword">false</span>);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">char</span> c_;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespaceasio.html">asio</a> {</div><div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_match_condition&lt;match_char&gt;</div><div class="line">    : <span class="keyword">public</span> boost::true_type {};</div><div class="line">} <span class="comment">// namespace asio</span></div><div class="line">...</div><div class="line">asio::streambuf b;</div><div class="line"><a class="code" href="group__read__until.html#ga6b5fe90ae4647674f61b3b2e80cb155c">asio::read_until</a>(s, b, match_char(<span class="charliteral">&#39;a&#39;</span>));</div></div><!-- fragment --> 
</div>
</div>
<a id="gaacb23419d8878f33e469e3f743c738d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacb23419d8878f33e469e3f743c738d6">&#9670;&nbsp;</a></span>read_until() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SyncReadStream , typename Allocator , typename MatchCondition &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t asio::read_until </td>
          <td>(</td>
          <td class="paramtype">SyncReadStream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatchCondition&#160;</td>
          <td class="paramname"><em>match_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1error__code.html">asio::error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structasio_1_1is__match__condition.html">is_match_condition</a>&lt; MatchCondition &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data into a streambuf until a function object indicates a match. </p>
<p>This function is used to read data into the specified streambuf until a user-defined match condition function object, when applied to the data contained in the streambuf, indicates a successful match. The call will block until one of the following conditions is true:</p>
<ul>
<li>The match condition function object returns a std::pair where the second element evaluates to true.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the stream's read_some function. If the match condition function object already indicates a match, the function returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The stream from which the data is to be read. The type must support the SyncReadStream concept.</td></tr>
    <tr><td class="paramname">b</td><td>A streambuf object into which the data will be read.</td></tr>
    <tr><td class="paramname">match_condition</td><td>The function object to be called to determine whether a match exists. The signature of the function object must be: <div class="fragment"><div class="line">pair&lt;iterator, bool&gt; match_condition(iterator begin, iterator end);</div></div><!-- fragment --> where <code>iterator</code> represents the type: <div class="fragment"><div class="line">buffers_iterator&lt;basic_streambuf&lt;Allocator&gt;::const_buffers_type&gt;</div></div><!-- fragment --> The iterator parameters <code>begin</code> and <code>end</code> define the range of bytes to be scanned to determine whether there is a match. The <code>first</code> member of the return value is an iterator marking one-past-the-end of the bytes that have been consumed by the match function. This iterator is used to calculate the <code>begin</code> parameter for any subsequent invocation of the match condition. The <code>second</code> member of the return value is true if a match has been found, false otherwise.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the streambuf's get area that have been fully consumed by the match function. Returns 0 if an error occurred.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>After a successful read_until operation, the streambuf may contain additional data beyond that which matched the function object. An application will typically leave that data in the streambuf for a subsequent read_until operation to examine.</dd>
<dd>
The default implementation of the <code><a class="el" href="structasio_1_1is__match__condition.html" title="Type trait used to determine whether a type can be used as a match condition function with read_until...">is_match_condition</a></code> type trait evaluates to true for function pointers and function objects with a <code>result_type</code> typedef. It must be specialised for other user-defined function objects. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
