<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asio Reference: asio::async_write_at</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asio Reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">asio::async_write_at</div>  </div>
</div><!--header-->
<div class="contents">

<p>Start an asynchronous operation to write a certain amount of data at the specified offset.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">asio::async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga5a8bb16f508135058a13f4a62eda57b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data at the specified offset.  <a href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">More...</a><br /></td></tr>
<tr class="separator:ga5a8bb16f508135058a13f4a62eda57b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#ga66f04a7490faac4ebbc66c5b9ed59514">asio::async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, const ConstBufferSequence &amp;buffers, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data at the specified offset.  <a href="group__async__write__at.html#ga66f04a7490faac4ebbc66c5b9ed59514">More...</a><br /></td></tr>
<tr class="separator:ga66f04a7490faac4ebbc66c5b9ed59514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacc38874d2274f01b8abeb075b1b783d"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gaacc38874d2274f01b8abeb075b1b783d"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#gaacc38874d2274f01b8abeb075b1b783d">asio::async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gaacc38874d2274f01b8abeb075b1b783d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write all of the supplied data at the specified offset.  <a href="group__async__write__at.html#gaacc38874d2274f01b8abeb075b1b783d">More...</a><br /></td></tr>
<tr class="separator:gaacc38874d2274f01b8abeb075b1b783d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cc0a03a3667674bb903567afc2952d"><td class="memTemplParams" colspan="2">template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , typename WriteHandler &gt; </td></tr>
<tr class="memitem:gae0cc0a03a3667674bb903567afc2952d"><td class="memTemplItemLeft" align="right" valign="top">void_or_deduced&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__async__write__at.html#gae0cc0a03a3667674bb903567afc2952d">asio::async_write_at</a> (AsyncRandomAccessWriteDevice &amp;d, uint64_t offset, <a class="el" href="classasio_1_1basic__streambuf.html">basic_streambuf</a>&lt; Allocator &gt; &amp;b, CompletionCondition completion_condition, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="memdesc:gae0cc0a03a3667674bb903567afc2952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start an asynchronous operation to write a certain amount of data at the specified offset.  <a href="group__async__write__at.html#gae0cc0a03a3667674bb903567afc2952d">More...</a><br /></td></tr>
<tr class="separator:gae0cc0a03a3667674bb903567afc2952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Start an asynchronous operation to write a certain amount of data at the specified offset. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5a8bb16f508135058a13f4a62eda57b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a8bb16f508135058a13f4a62eda57b0">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to write all of the supplied data at the specified offset. </p>
<p>This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div><div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">asio::async_write_at</a>(d, 42, <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size), handler);</div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="ga66f04a7490faac4ebbc66c5b9ed59514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66f04a7490faac4ebbc66c5b9ed59514">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename ConstBufferSequence , typename CompletionCondition , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstBufferSequence &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to write a certain amount of data at the specified offset. </p>
<p>This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied buffers has been written. That is, the bytes transferred is equal to the sum of the buffer sizes.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">buffers</td><td>One or more buffers containing the data to be written. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div><div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div><div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>To write a single data buffer use the <a class="el" href="group__buffer.html">asio::buffer</a> function as follows: <div class="fragment"><div class="line"><a class="code" href="group__async__write__at.html#ga5a8bb16f508135058a13f4a62eda57b0">asio::async_write_at</a>(d, 42,</div><div class="line">   <a class="code" href="group__buffer.html#ga5d7f73ad7f12e3bd045b206b1355f3b9">asio::buffer</a>(data, size),</div><div class="line">   <a class="code" href="group__completion__condition.html#gadba1ed43445276e2b563a59663ca26cd">asio::transfer_at_least</a>(32),</div><div class="line">   handler); </div></div><!-- fragment --> See the <a class="el" href="group__buffer.html">asio::buffer</a> documentation for information on writing multiple buffers in one go, and how to use it with arrays, boost::array or std::vector. </dd></dl>

</div>
</div>
<a id="gaacc38874d2274f01b8abeb075b1b783d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacc38874d2274f01b8abeb075b1b783d">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to write all of the supplied data at the specified offset. </p>
<p>This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>An error occurred.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div><div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae0cc0a03a3667674bb903567afc2952d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0cc0a03a3667674bb903567afc2952d">&#9670;&nbsp;</a></span>async_write_at() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AsyncRandomAccessWriteDevice , typename Allocator , typename CompletionCondition , typename WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void_or_deduced asio::async_write_at </td>
          <td>(</td>
          <td class="paramtype">AsyncRandomAccessWriteDevice &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classasio_1_1basic__streambuf.html">asio::basic_streambuf</a>&lt; Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CompletionCondition&#160;</td>
          <td class="paramname"><em>completion_condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start an asynchronous operation to write a certain amount of data at the specified offset. </p>
<p>This function is used to asynchronously write a certain number of bytes of data to a random access device at a specified offset. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>All of the data in the supplied <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> has been written.</li>
</ul>
<ul>
<li>The completion_condition function object returns 0.</li>
</ul>
<p>This operation is implemented in terms of zero or more calls to the device's async_write_some_at function, and is known as a <em>composed operation</em>. The program must ensure that the device performs no <em>overlapping</em> write operations (such as async_write_at, the device's async_write_some_at function, or any other composed operations that perform writes) until this operation completes. Operations are overlapping if the regions defined by their offsets, and the numbers of bytes to write, intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The device to which the data is to be written. The type must support the AsyncRandomAccessWriteDevice concept.</td></tr>
    <tr><td class="paramname">offset</td><td>The offset at which the data will be written.</td></tr>
    <tr><td class="paramname">b</td><td>A <a class="el" href="classasio_1_1basic__streambuf.html" title="Automatically resizable buffer class based on std::streambuf. ">basic_streambuf</a> object from which data will be written. Ownership of the streambuf is retained by the caller, which must guarantee that it remains valid until the handler is called.</td></tr>
    <tr><td class="paramname">completion_condition</td><td>The function object to be called to determine whether the write operation is complete. The signature of the function object must be: <div class="fragment"><div class="line"> std::size_t completion_condition(</div><div class="line">  <span class="comment">// Result of latest async_write_some_at operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes transferred so far.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> A return value of 0 indicates that the write operation is complete. A non-zero return value indicates the maximum number of bytes to be written on the next call to the device's async_write_some_at function.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">  <span class="comment">// Result of operation.</span></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classasio_1_1error__code.html">asio::error_code</a>&amp; <a class="code" href="namespaceasio_1_1placeholders.html#a441d03324a306a3f2e2c4c72485fdf4e">error</a>,</div><div class="line"></div><div class="line">  <span class="comment">// Number of bytes written from the buffers. If an error</span></div><div class="line">  <span class="comment">// occurred, this will be less than the sum of the buffer sizes.</span></div><div class="line">  std::size_t bytes_transferred</div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <a class="el" href="classasio_1_1io__context.html#a580e42c6a22843dfa11097ffb1898f42" title="(Deprecated: Use asio::post().) Request the io_context to invoke the given handler and return immedia...">asio::io_context::post()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
